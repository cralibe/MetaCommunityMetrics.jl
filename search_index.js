var documenterSearchIndex = {"docs":
[{"location":"#MetaCommunityMetrics.jl","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"A collection of tools and utilities for analyzing meta-communities in Julia.","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#Getting-Started","page":"MetaCommunityMetrics.jl","title":"Getting Started","text":"","category":"section"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"###Installation","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"using Pkg\nPkg.add(\"MetaCommunityMetrics\")\nusing MetaCommunityMetrics","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"##Functions","category":"page"},{"location":"","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.jl","text":"beta_diversity(mat::Matrix; quant::Bool)\nmean_spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool)\nmean_temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool)\ncreate_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int})\nplot_clusters(grouped_data::DataFrame)\nDNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000, count::Bool=true)","category":"page"},{"location":"#MetaCommunityMetrics.beta_diversity-Tuple{Matrix{T} where T}","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative data. For binary data, the function calculates Podani family, Jaccard-based indices. For quantitative data, the function calculates Podani family, Ruzicka-based indices. The function returns a DataFrame containing the calculated beta diversity indices.  Empty patches have to be removed before calculation. Please refer to Example.jl for more details.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a sample and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: A boolean flag that indicates whether the data is quantitative. Default is false, which means the data is treated as binary.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects how many species are different in one site compared to another, ignoring the species that are mere additions or subtractions.\nRichDif: Richness difference component of diversity, which captures the disparity in biodiversity in terms of the count of species present, without taking into account the specific identities or distributions of those species.\n\n\n\n\n\n","category":"method"},{"location":"#MetaCommunityMetrics.mean_spatial_beta_div-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Union{String, AbstractVector{T} where T}, Union{String, AbstractVector{T} where T}}","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.mean_spatial_beta_div","text":"mean_spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool) -> DataFrame\n\nCalculate the mean spatial beta diversity components of a metacommunity over time based on species abundances or presence-absences.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: Optional boolean flag to indicate whether the data should be treated as quantitative (default is false, treating data as binary presence/absence).\n\nReturns\n\nDataFrame: A DataFrame containing the mean values of total beta diversity, replacement, and richness difference components across all time points. Columns are mean_spatial_BDtotal, mean_spatial_Repl, and mean_spatial_RichDif.\n\n\n\n\n\n","category":"method"},{"location":"#MetaCommunityMetrics.mean_temporal_beta_div-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Union{String, AbstractVector{T} where T}, Union{String, AbstractVector{T} where T}}","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.mean_temporal_beta_div","text":"mean_temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool) -> DataFrame\n\nCalculate the mean temporal beta diversity components acorss all patches based on species abundances or presence-absences.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: Optional boolean flag to indicate whether the data should be treated as quantitative (default is false, treating data as binary presence/absence).\n\nReturns\n\nDataFrame: A DataFrame containing the mean values of total beta diversity, replacement, and richness difference components across all pactches. Columns are mean_temporal_BDtotal, mean_temporal_Repl, and mean_temporal_RichDif.\n\n\n\n\n\n","category":"method"},{"location":"#MetaCommunityMetrics.create_clusters-Tuple{Vector{Int64}, Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int}) -> Dict{Int, DataFrame}\n\nCreate clusters for each unique time step in a dataset. Only presnece-absence data can be used.\n\nArguments\n\ntime::Vector: A vector indicating the time each sample was taken.\nlatitude::Vector: A vector indicating the latitude of each sample.\nlongitude::Vector: A vector indicating the longitude of each sample.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key is a unique time from the dataset and each value is a DataFrame for that time with an added Group column indicating the assigned cluster.\n\nDetails\n\nThis function performs hierarchical clustering on geographical coordinates for each unique time step. It aims to balance the clusters based on the number of sites and species richness, ensuring that no group has less than five sites and that there are at least two groups. If conditions for clustering balance are not met (like groups having less than five sites or only one group), it iteratively adjusts the clusters by reassigning sites to improve group balance.\n\nExample\n\nusing CSV, DataFrames\nusing DataFramesMeta\nusing Pipe: @pipe\n\nsample_df = @pipe CSV.read(\"data/rodent_abundance_data.csv\", DataFrame; header=true) |>#read in the sample data\n            select(_, Not(:Column1))|> #select the columns \n            stack(_, Not(:Sampling_date_order, :Year, :Month, :Day, :plot), variable_name = :species, value_name = :abundance)\n\npreped_data= @pipe sample_df |>         \n@transform(_, :presence = ifelse.(:abundance .>= 1, 1, 0)) |>\ngroupby(_, [:Sampling_date_order, :species]) |> \ncombine(_,:presence=>sum=>:total_presence) |>\nfilter(row -> row[:total_presence] !<= 1, _) |> #remove singletons (species occurring at one site only)\nleftjoin(_,sample_df, on = [:Sampling_date_order, :species]) |> #join the data back to the original data\n\n\n# Generate random latitude and longitude values\nn = nrow(sample_df)\nlatitude = rand(35.0:0.01:36.0, n) # Adjust range as needed\nlongitude = rand(-120.0:0.01:-119.0, n) # Adjust range as needed\n\n# Add the coordinates to the DataFrame\nsample_df[:, :latitude] = latitude\nsample_df[:, :longitude] = longitude\n\n# Create groups for each time step\ngrouped_data = create_clusters(sample_df.Sampling_date_order, sample_df.latitude, sample_df.longitude, sample_df.plot)\n\n\n\n\n\n\n","category":"method"},{"location":"#MetaCommunityMetrics.plot_clusters-Tuple{DataFrames.DataFrame}","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(grouped_data::DataFrame)\n\nThis function plots the clustering result from the function create_clusters() on a scatter plot according to geographic coordinates. Each point represents a location, and points are colored based on their group/cluster ID.\n\nArguments\n\ngrouped_data::DataFrame: A DataFrame containing the columns Latitude, Longitude, and Group. \nLatitude: A column of latitude coordinates.\nLongitude: A column of longitude coordinates.\nGroup: A column indicating the cluster ID for each point.\n\nReturns\n\nReturns\n\nThis function displays a scatter plot of the clusters.\n\nDetails\n\nThe function extracts the Latitude, Longitude, and Group columns from the provided DataFrame.\nUnique cluster IDs are assigned numeric identifiers.\nA color palette is generated using distinguishable colors to differentiate the clusters.\nThe scatter plot is created with points colored by their cluster ID.\n\nExample\n\nusing DataFrames\n# Create a sample DataFrame\ndata = DataFrame(Latitude = [34.05, 36.16, 40.71, 34.05],\n                 Longitude = [-118.24, -115.15, -74.01, -118.24],\n                 Group = [\"A\", \"B\", \"A\", \"B\"])\n\n# Plot clusters\nplot_clusters(data)\n\n\n\n\n\n","category":"method"},{"location":"#MetaCommunityMetrics.DNCI_multigroup","page":"MetaCommunityMetrics.jl","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000, count::Bool=true)\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021) (doi: 10.1111/ecog.05356).\n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\ncount::Bool=true: A flag indicating whether the numeber of permutations is printed. Default is false.\n\nReturns\n\nDataFrame: A DataFrame containing the DNCI results for each pair of groups.\n\nExamples\n\n```julia\n\nExample usage of DNCI_multigroup\n\ncomm = [1 0 0 1 0;         1 1 0 0 0;         0 1 1 0 0;         0 0 1 1 1;         1 0 0 0 1;         0 1 1 0 1]\n\ngroups = [\"A\", \"A\", \"B\", \"B\", \"C\", \"C\"] Nperm = 1000 count = true\n\nresult = DNCI_multigroup(comm, groups, Nperm, count) println(result)\n\n\n\n\n\n","category":"function"}]
}
