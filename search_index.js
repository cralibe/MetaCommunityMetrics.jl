var documenterSearchIndex = {"docs":
[{"location":"NicheOverlapIndex/#Niche-Overlap-Index-Function","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"Niche overlap refers to the extent to which different species use the same resources or occupy similar ecological niches. High niche overlap might indicate intense competition, whereas low overlap suggests niche differentiation, allowing species to coexist by minimizing direct competition.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"To capture the changes in density-independent abiotic response, also known as niche breadth, this implementation uses Pianka's Niche Overlap Index, as suggested by Pianka (1973). The summary statistics of this index include the mean, maximum, and minimum values across all species pairs, providing a comprehensive understanding of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/#Functionality-Overview","page":"Niche Overlap Index Function","title":"Functionality Overview","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"The Niche Overlap Index functions in MetaCommunityMetrics provide a robust framework for calculating niche overlap based on species abundance or presence-absence data. These functions allow you to evaluate how species share ecological space within a metacommunity, offering valuable insights into community dynamics and species interactions.","category":"page"},{"location":"NicheOverlapIndex/#The-Function","page":"Niche Overlap Index Function","title":"The Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"niche_overlap: This function calculates the Niche Overlap Index for a given set of species across different patches. It provides metrics for mean, minimum, and maximum niche overlap, allowing for a comprehensive assessment of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"niche_overlap","category":"page"},{"location":"NicheOverlapIndex/#MetaCommunityMetrics.niche_overlap","page":"Niche Overlap Index Function","title":"MetaCommunityMetrics.niche_overlap","text":"niche_overlap(abundance::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}, time::AbstractVector) -> DataFrame\n\nCalculates the overall mean, maximum, and minimum values of the niche overlap index from all species pairs in the provided data.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\nspecies::Union{AbstractVector, String}: Vector or string representing species names or IDs.\npatch::Union{AbstractVector, String}: Vector or string representing patch names or IDs.\ntime::AbstractVector: Vector representing the time points.\n\nDescription\n\nThe niche overlap index is calculated based on the method suggested by Pianka (1973), with the assumption that the proportional use of a species at a specific site and time equals its relative abundance at that site and time. To determine relative abundance, the abundance of each species in a particular patch is divided by the total abundance of that species across all patches and times.\n\nReturns\n\nDataFrame: A DataFrame containing the overall mean, maximum, and minimum values of the niche overlap index from all species pairs.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> result = niche_overlap(df.Abundance, df.Species, df.plot, df.Sampling_date_order)\n1×3 DataFrame\n Row │ mean_niche_overlap_index  min_niche_overlap_index  max_niche_overlap_index \n     │ Float64                   Float64                  Float64                 \n─────┼────────────────────────────────────────────────────────────────────────────\n   1 │                 0.827739                 0.591836                      1.0\n\n\n\n\n\n","category":"function"},{"location":"NicheOverlapIndex/#References","page":"Niche Overlap Index Function","title":"References","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"MacArthur, R. & Levins, R. The limiting similarity, convergence, and divergence of coexisting species. The American Naturalist 101, 377-385 (1967). \nPianka, E. R. (1974). \"Niche overlap and diffuse competition.\" Proceedings of the National Academy of Sciences, 71(5), 2141-2145.\nPianka, E. R. (1973). \"The Structure of Lizard Communities.\" Annual Review of Ecology and Systematics, 4(1), 53-74.","category":"page"},{"location":"#MetaCommunityMetrics.jl","page":"Home","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of tools and utilities for analyzing meta-communities in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#An-Overview","page":"Home","title":"An Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a comprehensive toolkit designed to characterize the spatiotemporal structure and dynamics of a metacommunity—a network of communities linked by the dispersal of multiple, interacting species, each with unique niche breadths. It includes functions to calculate a range of specific metrics, which have been previously implemented in R and proven valuable for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, they come with high computational costs, especially for large species community datasets. To address this issue, MetaCommunityMetrics.jl was developed in Julia, a programming language known for its efficiency in handling computationally intensive tasks. This implementation significantly improves the efficiency of calculating these metrics, making it a powerful tool for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beta diversity decompositions in space/time: total diversity, species replacement (turnover), and richness differences for both presence-absence and abundance data\nDispersal-niche continuum index to evaluate the degree to which communities are influenced by dispersal processes and niche breadth\nNiche overlap indices to determine the extent of niche sharing among species within the metacommunity\nThe proportion of habitat patches occupied by each species\nThe variability of community composition across different spatial and temporal scales","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"MetaCommunityMetrics\")\n\nusing MetaCommunityMetrics","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta Diversity\nDNCI\nNiche Overlap Index\nOccupied Patches Proportion\nVariability Metrics\nBenchmarking","category":"page"},{"location":"#Accessing-the-Sample-Data-for-exploring-the-functions","page":"Home","title":"Accessing the Sample Data for exploring the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes rodent data from the Portal Project, a long-term study of a Chihuahuan desert ecosystem (available at https://github.com/weecology/portalr), as sample data for testing and benchmarking functions between Julia and R. The original rodent abundance data were collected monthly across 24 plots, recording a total of 24 species. For the purposes of this package, the data are filtered for the period from 2010 to 2023, transformed into long format, and species that were not recorded during this period are removed. Additionally, plots with no observations at a given time step are excluded. A new column, Sampling_date_order, was created to sequentially number the sampling dates, starting at 1 and continuing through 117, to facilitate analysis. The locations of the plots (Latitude and Longitude) were simulated for testing the DNCI functions. The scripts to download and wrangle the data can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Downloading the rodent data\nData Wrangling","category":"page"},{"location":"","page":"Home","title":"Home","text":"To assess the sample data, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MetaCommunityMetrics\n\nload_sample_data()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using MetaCommunityMetrics\n\njulia> load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n     6 │  2010      1     16                    1     14  BA               0         0      36.0     -109.5\n     7 │  2010      1     16                    1     17  BA               0         0      36.0     -108.0\n     8 │  2010      1     16                    1     22  BA               0         0      36.5     -108.5\n     9 │  2010      1     16                    1      6  BA               0         0      35.0     -107.5\n    10 │  2010      1     16                    1     13  BA               0         0      36.0     -110.0\n    11 │  2010      1     16                    1     15  BA               0         0      36.0     -109.0\n    12 │  2010      1     16                    1     20  BA               0         0      36.5     -109.5\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48725 │  2023      3     21                  117     15  SH               1         1      36.0     -109.0\n 48726 │  2023      3     21                  117     19  SH               0         0      36.5     -110.0\n 48727 │  2023      3     21                  117     20  SH               0         0      36.5     -109.5\n 48728 │  2023      3     21                  117     21  SH               0         0      36.5     -109.0\n 48729 │  2023      3     21                  117     22  SH               0         0      36.5     -108.5\n 48730 │  2023      3     21                  117      1  SH               0         0      35.0     -110.0\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48712 rows omitted","category":"page"},{"location":"#Acknowledgment","page":"Home","title":"Acknowledgment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Acknowledgment","category":"page"},{"location":"OccupiedPatchesProportion/#Occupied-Patches-Proportion-Function","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion function in MetaCommunityMetrics provides a simple yet powerful metric for understanding the distribution and prevalence of species across different habitat patches within a metacommunity. By calculating the averaged, minmum and maximum proportion of patches occupied across species, this function helps ecologists assess the spatial extent of species distributions and identify potential patterns of rarity or commonness across the landscape.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"This function draws on the concepts discussed by Ehrlén & Eriksson (2000) in their study on dispersal limitation and patchy occupancy in forest herbs. According to their findings, low occupancy may indicate dispersal limitation or strong competition, while high occupancy could suggest mass effects due to high dispersal rates or the ability to thrive in various conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#Functionality-Overview","page":"Occupied Patches Proportion Function","title":"Functionality Overview","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion metric quantifies the averaged proportion of habitat patches in which a species is present. This information is crucial for understanding species distributions, particularly in fragmented landscapes or patchy environments where species may not occupy all available habitat. This metric can be used to identify widespread species, which occupy a large number of patches, as well as rare species, which are restricted to only a few patches.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"After calculating the proportion of patches occupied for each species, the mean, minimum, and maximum proportion of patches occupied can be derived. These values are valuable indicators of ecological processes:","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Low proportion of patches occupied: May indicate dispersal limitation or strong competition among species. Such patterns could suggest that certain species struggle to colonize or persist in many patches.\nHigh proportion of patches occupied: May point to mass effects, where species are abundant in many patches, possibly due to high dispersal rates or the ability to thrive across a range of conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#The-Function","page":"Occupied Patches Proportion Function","title":"The Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"prop_patches","category":"page"},{"location":"OccupiedPatchesProportion/#MetaCommunityMetrics.prop_patches","page":"Occupied Patches Proportion Function","title":"MetaCommunityMetrics.prop_patches","text":"prop_patches(presence::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}) -> DataFrame\n\nCalculate the proportion of patches occupied by each species and summarize the results.\n\nThis function takes three vectors: presence, species, and patch, and performs the following steps:\n\nArguments\n\npresence::AbstractVector: A vector indicating the presence (1) or absence (0) of a species in a patch.\nspecies::Union{AbstractVector, String}: A vector of species names.\npatch::Union{AbstractVector, String}: A vector of patch identifiers.\n\nReturns\n\nDataFrame: A DataFrame containing the mean, minimum, and maximum proportion of patches               occupied across all species.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> prop_patches(df.Presence, df.Species, df.plot)\n1×3 DataFrame\n Row │ mean_prop_patches  min_prop_patches  max_prop_patches \n     │ Float64            Float64           Float64          \n─────┼───────────────────────────────────────────────────────\n   1 │          0.734649         0.0833333               1.0\n\n\n\n\n\n","category":"function"},{"location":"OccupiedPatchesProportion/#References","page":"Occupied Patches Proportion Function","title":"References","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Ehrlén, J., & Eriksson, O. (2000). Dispersal Limitation and Patchy Occupancy in Forest Herbs. Ecology, 81(6), 1667-1674. https://doi.org:https://doi.org/10.1890/0012-9658(2000)081[1667:DLAPOI]2.0.CO;2","category":"page"},{"location":"BetaDiversity/#Beta-Diversity-Functions","page":"Beta Diverisity Functions","title":"Beta Diversity Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Beta diversity is a fundamental concept in ecology that quantifies the variation in species composition between different plots, or over time. In the context of metacommunity analysis, beta diversity functions help to assess how community composition changes spatially across different locations or temporally within a metacommunity.","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"The beta_diversity functions in MetaCommunityMetrics are adapted from the beta.div.comp function in the R package adespatial. These methods, originally developed by Pierre Legendre (2014), are implemented in Julia to provide a more efficient means of computation for large-scale datasets. The functions use indices from the Podani family, Jaccard-based indices, and Ruzicka-based indices to calculate total beta diversity and its components: replacement and richness difference.","category":"page"},{"location":"BetaDiversity/#Choosing-the-Right-Function","page":"Beta Diverisity Functions","title":"Choosing the Right Function","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Use beta_diversity for a general, comprehensive measure of beta diversity across your dataset. This function provides an overall assessment of how species composition varies between sites or over time, capturing both replacement (the turnover of species) and richness difference(the difference in species richness). \nUse spatial_beta_div to comparing diversity between different spatial locations of a metacommunity. \nUse temporal_beta_div to track how diversity changes over time of a metacommunity. ","category":"page"},{"location":"BetaDiversity/#The-Functions","page":"Beta Diverisity Functions","title":"The Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"beta_diversity\nspatial_beta_div\ntemporal_beta_div","category":"page"},{"location":"BetaDiversity/#MetaCommunityMetrics.beta_diversity","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative data.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a sample and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects how many species are different in one site compared to another, ignoring the species that are mere additions or subtractions.\nRichDif: Richness difference component of diversity, which captures the disparity in biodiversity in terms of the count of species present, without taking into account the specific identities or distributions of those species.\n\nDetails\n\nEmpty patches have to be removed before calculation.\nSpecies that were not recorded at the given time step have to be removed before calculation.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThis function is a translation/adaptation of the beta.dov.comp function from the R package adespatial,licensed under GPL-3.\nOriginal package and documentation available at: https://cran.r-project.org/web/packages/adespatial/index.html\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> matrix_with_abundance =  @pipe df |>\n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           select(_, Not(:Presence)) |>\n           unstack(_, :Species, :Abundance, fill=0) |>\n           select(_, Not(:Year, :Month, :Day, :Sampling_date_order, :plot, :Longitude, :Latitude)) |> \n           Matrix(_) |> \n           x -> x[:, sum(x, dims=1)[1, :] .!= 0] |> \n           x -> x[vec(sum(x, dims=2)) .!= 0, :]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 2  0  0  0  0\n 1  0  0  1  0\n 4  0  0  1  0\n 1  0  0  0  0\n 0  1  0  0  1\n 0  0  0  1  0\n 0  0  0  2  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> matrix_with_presence = @pipe df |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           select(_, Not(:Abundance)) |>\n           unstack(_, :Species, :Presence, fill=0) |> #convert it back to the wide format \n           select(_, Not(:Year, :Month, :Day, :Sampling_date_order, :plot, :Longitude, :Latitude)) |> \n           Matrix(_) |>     \n           x -> x[:, sum(x, dims=1)[1, :] .!= 0]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  1  0\n 1  0  0  1  0\n 1  0  0  0  0\n 0  1  0  0  1\n 0  0  0  1  0\n 0  0  0  1  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> result_using_abanduce_data_1 = beta_diversity(matrix_with_abundance; quant=true)\n1×3 DataFrame\n Row │ BDtotal   Repl     RichDif  \n     │ Float64   Float64  Float64  \n─────┼─────────────────────────────\n   1 │ 0.390317   0.2678  0.122517\n\njulia> result_using_abanduce_data_2 = beta_diversity(matrix_with_abundance; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\njulia> result_using_binary_data = beta_diversity(matrix_with_presence; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.spatial_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.spatial_beta_div","text":"spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in space based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in space. Columns are spatial_BDtotal, spatial_Repl, and spatial_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components after aggregating .\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in space is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> result_using_abanduce_data_1 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.264822      0.121882         0.142939\n        \njulia> result_using_abanduce_data_2 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\njulia> result_using_binary_data = spatial_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.temporal_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.temporal_beta_div","text":"temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in time based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in time. Columns are temporal_BDtotal, temporal_Repl, and temporal_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each patch.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in time is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> result_using_abanduce_data_1 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.311222      0.0995483          0.211674\n        \njulia> result_using_abanduce_data_2 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\njulia> result_using_binary_data = temporal_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#References","page":"Beta Diverisity Functions","title":"References","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Guzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683\nLegendre, P. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography 23, 1324-1334 (2014). https://doi.org:https://doi.org/10.1111/geb.12207","category":"page"},{"location":"VariabilityMetrics/#Variability-Metrics-Functions","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics functions in MetaCommunityMetrics are designed to capture changes in dispersal and density-dependent biotic interactions by investigating temporal variability and synchrony across spatial scales and organizational levels within a metacommunity. These functions are based on the work of Wang et al. (2019), which provides a framework for quantifying variability at different scales and contexts within a community.","category":"page"},{"location":"VariabilityMetrics/#Overview","page":"Variability Metrics Functions","title":"Overview","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In MetaCommunityMetrics, the CV_meta_simple function is directly adapted from the R function var.partition in Wang et al. (2019). This function is designed with computational efficiency in mind, particularly for large datasets, by avoiding the calculation of all covariances between species. This approach ensures faster performance while still providing valuable insights into variability across different scales within a metacommunity.","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In contrast, the CV_meta function extends the analysis by including the calculation of all covariances between species, offering a more detailed and comprehensive examination of variability. This approach captures interactions between species that may be overlooked by more streamlined methods. While the CV_meta function provides a richer analysis, the CV_meta_simple function remains a valuable tool when computational efficiency is a priority.","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"These metrics are designed to quantify variability at different scales and contexts within the community:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Local-scale average species variability (CV_s_l)\nRegional-scale average species variability (CV_s_r)\nLocal-scale average community variability (CV_c_l)\nRegional-scale community variability (CV_c_r)","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics are calculated as follows:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics CV_s_l, CV_s_r, CV_c_l, and CV_c_r are set to zero whenever the mean abundance equals zero at any combination of spatial scales (a patch/all patches) and species number (a species/the whole community). This approach allows us to assess the impact of spatial scale on variability and to understand how different factors influence community dynamics across scales.","category":"page"},{"location":"VariabilityMetrics/#The-Function","page":"Variability Metrics Functions","title":"The Function","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"CV_meta\nCV_meta_simple","category":"page"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta","text":"CV_meta(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates various coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nDetails This function calculates the coefficients of variation (CV) for species and community biomass at both local and regional scales. The calculation involves several steps:\n\nReorganization of Data: The input data is organized into a DataFrame with columns for abundance, time, plot, and species.\nMean Calculations: Temporal mean species abundance is calculated for each species in each patch, as well as the overall temporal mean biomass.\nTemporal Variance Calculations: Temporal variance is calculated for each species within patches, for species across patches, for the community biomass within patches, and for the overall metacommunity biomass.\nCV Calculations: The coefficients of variation are calculated for species and community biomass at both local and regional scales.\nOutput: The results are returned in a DataFrame summarizing the CVs for local and regional scales.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data() |>\n                          filter(row -> row[:Sampling_date_order] < 20, _)\n6764×10 DataFrame\n  Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n      │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n──────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n    2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n    3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n    4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n    5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n  ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 6760 │  2012      1     21                   19     21  SH               0         0      36.5     -109.0\n 6761 │  2012      1     21                   19      5  SH               0         0      35.0     -108.0\n 6762 │  2012      1     21                   19      7  SH               0         0      35.5     -110.0\n 6763 │  2012      1     21                   19     23  SH               0         0      36.5     -108.0\n 6764 │  2012      1     21                   19     24  SH               0         0      36.5     -107.5\n                                                                                          6754 rows omitted\n                                                                                          \njulia> CV_summary_df = CV_meta(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.05607  0.813324  0.656184  0.537299\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta_simple","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta_simple","text":"CV_meta_simple(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity, using a simpler approach optimized for handling larger datasets.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nDetails This function is a simplified version of the CV_meta function, designed to efficiently handle larger datasets by avoiding complex covariance calculations. The steps include:\n\nReorganization of Data: The input data is organized into a DataFrame with columns for abundance, time, plot, and species, and then transformed into a 3D abundance matrix.\nTotal Abundance Calculations: The function calculates total abundances for species across time, within each patch, and for the entire metacommunity.\nStandard Deviation (SD) Calculations: Temporal standard deviations of abundance are computed for the entire metacommunity, each patch, and each species.\nCV Calculations: The coefficients of variation are calculated for species and community biomass at both local and regional scales.\nOutput: The results are returned in a DataFrame summarizing the CVs for local and regional scales.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data() |>\n                          filter(row -> row[:Sampling_date_order] < 20, _)\n6764×10 DataFrame\n  Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n      │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n──────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n    2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n    3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n    4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n    5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n  ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 6760 │  2012      1     21                   19     21  SH               0         0      36.5     -109.0\n 6761 │  2012      1     21                   19      5  SH               0         0      35.0     -108.0\n 6762 │  2012      1     21                   19      7  SH               0         0      35.5     -110.0\n 6763 │  2012      1     21                   19     23  SH               0         0      36.5     -108.0\n 6764 │  2012      1     21                   19     24  SH               0         0      36.5     -107.5\n                                                                                          6754 rows omitted\n\njulia> CV_summary_df = CV_meta_simple(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.20808  0.918862  0.801216  0.665082\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#References","page":"Variability Metrics Functions","title":"References","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290","category":"page"},{"location":"Acknowledgment/#Acknowledgment","page":"Acknowledgment","title":"Acknowledgment","text":"","category":"section"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package includes translations and adaptations of functions from the R packages adespatial (licensed under GPL-3), vegan (licensed under GPL-2 or later), and DNCImper (licensed under GPL-3). The original packages and their documentation are available at:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"adespatial: https://cran.r-project.org/web/packages/adespatial/index.html\nvegan: https://cran.r-project.org/web/packages/vegan/index.html\nDNCImper: https://github.com/Corentin-Gibert-Paleontology/DNCImper","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Please refer to these sources for full details on the original implementations and licenses.","category":"page"},{"location":"Benchmarking/#Benchmarking-Results","page":"Benchmarking Julia vs R","title":"Benchmarking Results","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"Benchmarking/#Computational-Resources","page":"Benchmarking Julia vs R","title":"Computational Resources","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"All benchmarks were performed on the same machine to ensure consistent comparisons.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"CPU: Apple M1 Pro\nNumber of Cores: 10\nMemory: 16GB RAM\nOperating System: macOS Sonoma 14.7\nJulia Version: 1.9.3\nR Version: 4.3.1","category":"page"},{"location":"Benchmarking/#Direct-Comparison-(When-an-equivalent-fuction-in-R-is-avaliable)","page":"Benchmarking Julia vs R","title":"Direct Comparison (When an equivalent fuction in R is avaliable)","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Below is a comparison of the benchmarking results between my Julia package and functions/equivalent implementation in R. All times are in millisecond, and memory is in mebibytes (MiB). Only mean execution times are presented here.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Test Case Julia Execution Time R Execution Time Speedup (Julia/R) Memory Usage (Julia) Memory Usage (R) R Function and Package used\nbeta_diversity_1 0.118 2.248 19x 0.132 0.057 beta.div.comp from adespatial\nbeta_diversity_2 0.039 0.270 7x 0.133 0.125 beta.div.comp from adespatial\nbeta_diversity_3 0.038 0.280 7x 0.133 0.125 beta.div.comp from adespatial\nspatial_beta_div_1 0.954 19.530 20x 2.300 3.451 implementation from Guzman et al. (2022)\nspatial_beta_div_2 0.631 17.106 27x 1.900 3.009 implementation from Guzman et al. (2022)\nspatial_beta_div_3 0.586 16.742 29x 1.900 3.009 implementation from Guzman et al. (2022)\ntemporal_beta_div_1 9.012 86.396 10x 14.760 17.342 implementation from Guzman et al. (2022)\ntemporal_beta_div_2 1.439 20.516 14x 3.540 5.630 implementation from Guzman et al. (2022)\ntemporal_beta_div_3 1.438 21.006 15x 3.540 5.630 implementation from Guzman et al. (2022)\nDNCI_multigroup_result 261.033 45849.450 176x 407.07 10630.390 DNCI_multigroup from DNCImper\nprop_patches_result 1.491 18.726 13x 2.320 2.412 implementation from Guzman et al. (2022)\nCV_meta_simple_result 105.155 152.730 1x 35.41 55.435 implementation from Wang et al. (2019)","category":"page"},{"location":"Benchmarking/#Self-Benchmarking-(For-Julia-Only-Functions)","page":"Benchmarking Julia vs R","title":"Self-Benchmarking (For Julia-Only Functions)","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"These functions are unique to the Julia package and do not have equivalents in R. We provide benchmarks in terms of execution time and memory usage as a point of comparison for future work or potential replication in other languages. All times are in millisecond, and memory is in mebibytes (MiB). Only mean execution times are presented here.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Test Case Julia Execution Time Memory Usage (Julia) Data Size (row, column)\ncluster_result 1.601 916.880 2545, 5\nplot_clusters_result 3.656 817.930 23, 3\nniche_overlap_result 6823.000 118.280 48735, 4\nCV_meta_result 161600.000 96317.44 48735, 4","category":"page"},{"location":"Benchmarking/#Remarks","page":"Benchmarking Julia vs R","title":"Remarks","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Speedup is calculated as the ratio of R execution time to Julia execution time and rounded to the nearest integer. \nThe test case names are assigned according to the object names used for the benchmarking results. If applicable, the same object name is used for the same test case between Julia and R for consistency.\nThe same data input are used in Julia and R for each test case.\nFor CV_meta_simple_result and CV_meta_result, they are both benchmarked using the same dataset (48735, 4).\nFor DNCI_multigroup_result, 100 permutations are used in both the julia and R function.","category":"page"},{"location":"Benchmarking/#The-Scripts-Used-for-Benchmarking","page":"Benchmarking Julia vs R","title":"The Scripts Used for Benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Julia\nR","category":"page"},{"location":"DNCI/#Dispersal-Niche-Continuum-Index-(DNCI)-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The Dispersal-Niche Continuum Index (DNCI) functions in MetaCommunityMetrics quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. The function DNCI_multigroup  in this package is adapted from the R package DNCImper: Assembly process identification based on SIMPER analysis. These methods, originally developed by Clarke(1993) and later refined by Gibert & Escarguel(2019) and Vilmi et al.(2021), offer powerful tools for identifying the processes underlying species assembly in metacommunities. ","category":"page"},{"location":"DNCI/#Background","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Background","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions is built around the Per-SIMPER and DNCI analyses. PerSIMPER, based on the Similarity Percentage (SIMPER) analysis developed by Clarke (1993), assesses the contribution of individual taxa to overall dissimilarity (OAD) between groups of assemblages. PerSIMPER enhances this by comparing empirical SIMPER plots with randomized plots generated through matrix permutation, which helps identify whether niche, dispersal, or both processes are driving community assembly.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI (Dispersal-Niche Continuum Index) further extends this approach by transforming the qualitative results of PerSIMPER into a quantitative index, providing a straightforward measure of the influence of niche and dispersal processes on community structure.","category":"page"},{"location":"DNCI/#Functionality-Overview","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Functionality Overview","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions in MetaCommunityMetrics allow you to analyze the processes driving species assembly within your dataset. By comparing empirical data with randomized permutations, one can determine the extent to which niche and dispersal processes influence the structure of metacommunities. Before calculating the DNCI, groupings of sites (clusters) are required, as the DNCI relies on analyzing community composition across spatial groups. This package provides a function to perform the necessary clustering, which is not available in the equivalent R package. When the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. In contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. If the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.","category":"page"},{"location":"DNCI/#The-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"The Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"create_clusters: Groups sampling locations based on their spatial attributes and species richness, which can then be used to assess DNCI.\nplot_clusters: Visualizes the clusters created, allowing for an intuitive understanding of spatial groupings.\nDNCI_multigroup: Computes the Dispersal-Niche Continuum Index (DNCI) across multiple groups, helping to quantify the relative influence of niche versus dispersal processes.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"create_clusters\nplot_clusters","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.create_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int}, total_richness::Vector{Int}) -> Dict{Int, DataFrame}\n\nThis function creates clusters (groupings of patches/sites) for each unique time step in a dataset which can then used for calculating DNCI. Only presnece-absence data can be used. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ntime::Vector: A vector indicating the time each sample was taken.\nlatitude::Vector: A vector indicating the latitude of each sample.\nlongitude::Vector: A vector indicating the longitude of each sample.\npatch::Vector: A vector indicating the spatial location (patch) of each sample. At least 10 patches are required for clustering.\ntotal_richness::Vector: A vector indicating the total species richness at each plot at each time step.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key represents a unique time point from the input data, with the corresponding value being a DataFrame for that time step. Each DataFrame contains the following columns: Time, Latitude, Longitude, Patch, Total_Richness, and Group (indicating the assigned cluster).\n\nDetails This function performs hierarchical clustering on the geographical coordinates of sampling patches/sites at each unique time step, assuming that organism dispersal occurs within the study region. It incorporates checks and adjustments to ensure the following conditions are met: at least 2 clusters, a minimum of 5 patches/sites per cluster, and that the variation in the number of taxa/species and patches/sites per group does not exceed 40% and 30%, respectively. These conditions are critical for calculating an unbiased DNCI value, and the function will issue warnings if any are not fulfilled.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#MetaCommunityMetrics.plot_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(latitude::Vector{Float64}, longitude::Vector{Float64}, group::Union{AbstractVector, String})\n\nPlots the clustering result at one time step of the create_cluster function using the geographic coordinates and cluster assignments of patches/sites.\n\nArguments\n\nlatitude::Vector{Float64}: A vector of latitude coordinates of the patches/sites.\nlongitude::Vector{Float64}: A vector of longitude coordinates of the patches/sites.\ngroup::Union{AbstractVector, String}: A vector or string indicating the cluster assignments for each data point.\n\nReturns\n\nA plot showing the patches/sites colored by the cluster assignment from the create_clusters function.\n\nDetails\n\nThe function assigns a unique color to each cluster and plots the patches/sites based on their geographic coordinates.\nThe patches/sites are colored according to the cluster assignment.\nThe plot includes black borders around the markers for better visibility.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> plot_clusters(result[1].Latitude, result[1].Longitude, result[1].Group)\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"This plot shows the clustering result for time step 1 based on geographic coordinates: (Image: Cluster Plot)","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"DNCI_multigroup","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.DNCI_multigroup","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000; count::Bool=true) -> DataFrame\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021). The DNCI quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix. You can use the create_clusters function to generate the group membership.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\ncount::Bool=true: A flag indicating whether the numeber of permutations is printed. Default is false.\n\nReturns\n\nDataFrame: A DataFrame containing the DNCI value, the associate confiden interval (CI_DNCI) and variance (S_DNCI) for each pair of groups.\n\nDetails\n\nThe function calculates the DNCI for each pair of groups in the input data.\nWhen the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. \nIn contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. \nIf the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.\nPlease remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\nThis function is a translation/adaptation of a function from the R package DNCImper, licensed under GPL-3.\nOriginal package and documentation available at: https://github.com/Corentin-Gibert-Paleontology/DNCImper\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> comm= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  innerjoin(_,  total_richness_df, on = [:plot, :Sampling_date_order], makeunique = true) |>\n                  filter(row -> row[:Sampling_date_order] == 1, _) |>\n                  select(_, [:plot, :Species, :Presence]) |>\n                  unstack(_, :Species, :Presence, fill=0) |>\n                  select(_, Not(:plot)) |>\n                  Matrix(_)\n14×3 Matrix{Int64}:\n 1  0  0\n 1  0  0\n 1  0  0\n 1  0  0\n 1  1  0\n 1  1  0\n 1  0  0\n 0  0  1\n 0  1  0\n 0  1  0\n 1  0  0\n 0  1  0\n 0  0  1\n 0  0  1\n\njulia> DNCI_result = DNCI_multigroup(comm, clustering_result[1].Group, 1000; count = false)\n1×5 DataFrame\n Row │ group1  group2  DNCI      CI_DNCI  S_DNCI  \n     │ Int64   Int64   Float64   Float64  Float64 \n─────┼────────────────────────────────────────────\n   1 │      1       2  0.533635  7.06888  3.53444\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#References","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"References","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"Clarke, K. R. Non-parametric multivariate analyses of changes in community structure. Australian Journal of Ecology 18, 117-143 (1993). https://doi.org:https://doi.org/10.1111/j.1442-9993.1993.tb00438.x\nGibert, C. & Escarguel, G. PER-SIMPER—A new tool for inferring community assembly processes from taxon occurrences. Global Ecology and Biogeography 28, 374-385 (2019). https://doi.org:https://doi.org/10.1111/geb.12859\nVilmi, A. et al. Dispersal–niche continuum index: a new quantitative metric for assessing the relative importance of dispersal versus niche processes in community assembly. Ecography 44, 370-379 (2021). https://doi.org:https://doi.org/10.1111/ecog.05356","category":"page"},{"location":"Hypervolume/#Hypervolume-Functions","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Hypervolume is a method originally proposed by Hutchinson (1957). It provide methods to calculate the volume of a niche for a given specice and thus the ncihe overlap between two species. It helps to infer how niche breath of species has contribute to the co-occurance of different species in the same location at the same time. The hypervolume functions provide by this package are adapted from the R package MVNH (https://github.com/lvmuyang/MVNH)","category":"page"},{"location":"Hypervolume/#The-Functions","page":"Hypervolume Functions","title":"The Functions","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"MVNH_det\nMVNH_dissimilarity\naverage_MVNH_det\naverage_MVNH_dissimilarity","category":"page"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_det","text":"MVNH_det(data::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate the niche hypervolume of a species based on environmental variables.\n\nArguments\n\ndata::DataFrame: DataFrame where each row represents an observation of a species (presence points) and columns represent environmental variables.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A DataFrame containing:\nCorrelation: The correlation component (calculated as det(COV)/prod(variances))\nOne column for each environmental variable showing its variance\ntotal: The total hypervolume (calculated as the determinant of the covariance matrix)\n\nDetails\n\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\nThe function computes the covariance matrix of the input data, extracts variances, and calculates the determinant\nThis function is a Julia implementation of the MVNH_det function from the R package MVNH (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n48735×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  temperature  precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64      Float64       \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0     19.0414         36.519\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5      9.38964        64.928\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5      9.47682        15.1981\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0     12.915          45.2296\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0     16.4379         42.2394\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮           ⋮             ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0     15.7166        159.86\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5     15.7419         96.5712\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5     20.0481         32.7878\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5     15.1438         34.5151\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0     15.854          80.9382\n                                                                                                                      48725 rows omitted\n\n\njulia> data = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:temperature, :precipitation])\n143×2 DataFrame\n Row │ temperature  precipitation \n     │ Float64      Float64       \n─────┼────────────────────────────\n   1 │   7.99303          64.8003\n   2 │   1.95878          48.6883\n   3 │  15.995            51.9702\n   4 │  -0.0812167        39.1034\n   5 │  19.1706           58.3263\n  ⋮  │      ⋮             ⋮\n 139 │  17.8614           66.4085\n 140 │  14.5365           12.0312\n 141 │  17.5499           14.3885\n 142 │  10.2389           34.7715\n 143 │  14.0303           39.0852\n                  133 rows omitted                                                                                 \n\njulia> result = MVNH_det(data; var_names=[\"Temperature\", \"Precipitation\"])\n1×4 DataFrame\n Row │ Correlation  Precipitation  Temperature  total   \n     │ Float64      Float64        Float64      Float64 \n─────┼──────────────────────────────────────────────────\n   1 │    0.997928        879.781      24.7847  21760.0\n\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_dissimilarity","text":"MVNH_dissimilarity(data_1::DataFrame, data_2::DataFrame; var_names::Vector{String}=String[]) -> Dict{String, DataFrame}\n\nCalculate niche dissimilarity between two species based on their environmental variables, using the Bhattacharyya distance and its components.\n\nArguments\n\ndata_1::DataFrame: DataFrame for the first species, where each row represents an observation and columns represent environmental variables.\ndata_2::DataFrame: DataFrame for the second species, with the same structure as data_1.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDict{String, DataFrame}: A dictionary containing three DataFrames:\n\"Bhattacharyya_distance\": The total Bhattacharyya distance and its components\n\"Mahalanobis_distance\": The Mahalanobis component of the Bhattacharyya distance\n\"Determinant_ratio\": The determinant ratio component of the Bhattacharyya distance\nEach DataFrame contains:\ntotal: The total value of the respective distance measure\ncorrelation: The correlation component of the distance measure\nOne column for each environmental variable showing its contribution to the distance\n\nDetails\n\nThe Bhattacharyya distance is calculated as the sum of two components:\nMahalanobis component: (1/8) × (μ₁-μ₂)ᵀ × (S₁+S₂)/2⁻¹ × (μ₁-μ₂)\nDeterminant ratio component: (1/2) × log(det((S₁+S₂)/2) / sqrt(det(S₁) × det(S₂)))\nEach component is further decomposed into individual variable contributions and correlation effects\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\nThis function is a Julia implementation inspired by the MVNH R package (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n48735×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  temperature  precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64      Float64       \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0     19.0414         36.519\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5      9.38964        64.928\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5      9.47682        15.1981\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0     12.915          45.2296\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0     16.4379         42.2394\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮           ⋮             ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0     15.7166        159.86\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5     15.7419         96.5712\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5     20.0481         32.7878\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5     15.1438         34.5151\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0     15.854          80.9382\n                                                                                                                      48725 rows omitted\n\n\njulia> data_1 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:temperature, :precipitation])\n143×2 DataFrame\n Row │ temperature  precipitation \n     │ Float64      Float64       \n─────┼────────────────────────────\n   1 │   7.99303          64.8003\n   2 │   1.95878          48.6883\n   3 │  15.995            51.9702\n   4 │  -0.0812167        39.1034\n   5 │  19.1706           58.3263\n  ⋮  │      ⋮             ⋮\n 139 │  17.8614           66.4085\n 140 │  14.5365           12.0312\n 141 │  17.5499           14.3885\n 142 │  10.2389           34.7715\n 143 │  14.0303           39.0852\n                  133 rows omitted\n\njulia> data_2 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"SH\", _) |>\n            select(_, [:temperature, :precipitation])\n58×2 DataFrame\n Row │ temperature  precipitation \n     │ Float64      Float64       \n─────┼────────────────────────────\n   1 │    16.5938         21.3197\n   2 │    16.1385         20.8511\n   3 │    18.4342         60.962\n   4 │    11.8572         49.7807\n   5 │    12.0075         30.7462\n  ⋮  │      ⋮             ⋮\n  54 │    12.206          23.0181\n  55 │    13.9233         62.2122\n  56 │    20.2339         37.0448\n  57 │     7.40668       116.384\n  58 │    20.0481         32.7878\n                   48 rows omitted\n                   \njulia> result = MVNH_dissimilarity(data_1, data_2; var_names=[\"Temperature\", \"Precipitation\"])\nDict{String, DataFrame} with 3 entries:\n  \"Determinant_ratio\"      => 1×4 DataFrame…\n  \"Bhattacharyya_distance\" => 1×4 DataFrame…\n  \"Mahalanobis_distance\"   => 1×4 DataFrame…\n\njulia> result[\"Determinant_ratio\"]\n1×4 DataFrame\n Row │ total       correlation  Temperature  Precipitation \n     │ Float64     Float64      Float64      Float64       \n─────┼─────────────────────────────────────────────────────\n   1 │ 0.00738662   2.84135e-5  0.000672539     0.00668567\n\njulia> result[\"Bhattacharyya_distance\"]\n1×4 DataFrame\n Row │ total      correlation  Temperature  Precipitation \n     │ Float64    Float64      Float64      Float64       \n─────┼────────────────────────────────────────────────────\n   1 │ 0.0100511  0.000122951   0.00296459     0.00696354\n\njulia> result[\"Mahalanobis_distance\"]\n1×4 DataFrame\n Row │ total       correlation  Temperature  Precipitation \n     │ Float64     Float64      Float64      Float64       \n─────┼─────────────────────────────────────────────────────\n   1 │ 0.00266447    9.4538e-5   0.00229205    0.000277876\n\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_det","text":"average_MVNH_det(data::DataFrame, presence_absence::Vector{Int}, species::Union{AbstractVector, String}; \n                 var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche hypervolume across multiple species in a community dataset.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Union{AbstractVector, String}: Vector containing species identifiers corresponding to each observation in data.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average hypervolume across all species with presence data.\n\nDetails\n\nFor each unique species, the function:\nFilters observations where the species is present (presence_absence = 1)\nCalculates the niche hypervolume using the MVNH_det function\nExtracts the total hypervolume value\nThe function then computes the mean of all individual species hypervolumes\nSpecies with no presence data are skipped in the calculation\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n48735×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  temperature  precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64      Float64       \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0     19.0414         36.519\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5      9.38964        64.928\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5      9.47682        15.1981\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0     12.915          45.2296\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0     16.4379         42.2394\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮           ⋮             ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0     15.7166        159.86\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5     15.7419         96.5712\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5     20.0481         32.7878\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5     15.1438         34.5151\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0     15.854          80.9382\n                                                                                                                      48725 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:temperature, :precipitation])\n           \n48735×2 DataFrame\n   Row │ temperature  precipitation \n       │ Float64      Float64       \n───────┼────────────────────────────\n     1 │    19.0414         36.519\n     2 │     9.38964        64.928\n     3 │     9.47682        15.1981\n     4 │    12.915          45.2296\n     5 │    16.4379         42.2394\n   ⋮   │      ⋮             ⋮\n 48731 │    15.7166        159.86\n 48732 │    15.7419         96.5712\n 48733 │    20.0481         32.7878\n 48734 │    15.1438         34.5151\n 48735 │    15.854          80.9382\n                  48725 rows omitted\n\njulia> result = average_MVNH_det(data, df.Presence, df.Species; var_names=[\"Temperature\", \"Precipitation\"])\n22427.757500223863\n\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_dissimilarity","text":"average_MVNH_dissimilarity(data::DataFrame, presence_absence::Vector{Int}, species::Union{AbstractVector, String}; \n                          var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche dissimilarity between all unique pairs of species in a community dataset using Bhattacharyya distance.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Union{AbstractVector, String}: Vector containing species identifiers corresponding to each observation in data.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average Bhattacharyya distance across all unique species pairs.\n\nDetails\n\nFor each unique pair of species, the function:\nFilters observations where each species is present (presence_absence = 1)\nCalculates the niche dissimilarity using the MVNH_dissimilarity function\nExtracts the total Bhattacharyya distance value\nThe function then computes the mean of all pairwise Bhattacharyya distances\nSpecies pairs where either species has no presence data are skipped\nEach species pair is processed only once (i.e., sp1-sp2 is calculated, but sp2-sp1 is skipped)\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n48735×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  temperature  precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64      Float64       \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0     19.0414         36.519\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5      9.38964        64.928\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5      9.47682        15.1981\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0     12.915          45.2296\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0     16.4379         42.2394\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮           ⋮             ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0     15.7166        159.86\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5     15.7419         96.5712\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5     20.0481         32.7878\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5     15.1438         34.5151\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0     15.854          80.9382\n                                                                                                                      48725 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:temperature, :precipitation])\n           \n48735×2 DataFrame\n   Row │ temperature  precipitation \n       │ Float64      Float64       \n───────┼────────────────────────────\n     1 │    19.0414         36.519\n     2 │     9.38964        64.928\n     3 │     9.47682        15.1981\n     4 │    12.915          45.2296\n     5 │    16.4379         42.2394\n   ⋮   │      ⋮             ⋮\n 48731 │    15.7166        159.86\n 48732 │    15.7419         96.5712\n 48733 │    20.0481         32.7878\n 48734 │    15.1438         34.5151\n 48735 │    15.854          80.9382\n                  48725 rows omitted\n\njulia> result = average_MVNH_dissimilarity(data, df.Presence, df.Species; var_names=[\"Temperature\", \"Precipitation\"])     \n0.029651910867403767\n\n\n\n\n\n\n","category":"function"}]
}
