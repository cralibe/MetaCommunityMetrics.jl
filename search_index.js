var documenterSearchIndex = {"docs":
[{"location":"OccupiedPatchesProportion/#Occupied-Patches-Proportion-Function","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion function in MetaCommunityMetrics provides a simple yet powerful metric for understanding the distribution and prevalence of species across different habitat patches within a metacommunity. By calculating the averaged, minmum and maximum proportion of patches occupied across species, this function helps ecologists assess the spatial extent of species distributions and identify potential patterns of rarity or commonness across the landscape.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"This function draws on the concepts discussed by Ehrlén & Eriksson (2000) in their study on dispersal limitation and patchy occupancy in forest herbs. According to their findings, low occupancy may indicate dispersal limitation or strong competition, while high occupancy could suggest mass effects due to high dispersal rates or the ability to thrive in various conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#Functionality-Overview","page":"Occupied Patches Proportion Function","title":"Functionality Overview","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion metric quantifies the averaged proportion of habitat patches in which a species is present. This information is crucial for understanding species distributions, particularly in fragmented landscapes or patchy environments where species may not occupy all available habitat. This metric can be used to identify widespread species, which occupy a large number of patches, as well as rare species, which are restricted to only a few patches.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"After calculating the proportion of patches occupied for each species, the mean, minimum, and maximum proportion of patches occupied can be derived. These values are valuable indicators of ecological processes:","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Low proportion of patches occupied: May indicate dispersal limitation or strong competition among species. Such patterns could suggest that certain species struggle to colonize or persist in many patches.\nHigh proportion of patches occupied: May point to mass effects, where species are abundant in many patches, possibly due to high dispersal rates or the ability to thrive across a range of conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#The-Function","page":"Occupied Patches Proportion Function","title":"The Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"prop_patches","category":"page"},{"location":"OccupiedPatchesProportion/#MetaCommunityMetrics.prop_patches","page":"Occupied Patches Proportion Function","title":"MetaCommunityMetrics.prop_patches","text":"prop_patches(presence::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}) -> DataFrame\n\nCalculate the proportion of patches occupied by each species and summarize the results.\n\nThis function takes three vectors: presence, species, and patch, and performs the following steps:\n\nArguments\n\npresence::AbstractVector: A vector indicating the presence (1) or absence (0) of a species in a patch.\nspecies::Union{AbstractVector, String}: A vector of species names.\npatch::Union{AbstractVector, String}: A vector of patch identifiers.\n\nReturns\n\nDataFrame: A DataFrame containing the mean, minimum, and maximum proportion of patches               occupied across all species.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> prop_patches(df.Presence, df.Species, df.plot)\n1×3 DataFrame\n Row │ mean_prop_patches  min_prop_patches  max_prop_patches \n     │ Float64            Float64           Float64          \n─────┼───────────────────────────────────────────────────────\n   1 │          0.734649         0.0833333               1.0\n\n\n\n\n\n","category":"function"},{"location":"OccupiedPatchesProportion/#References","page":"Occupied Patches Proportion Function","title":"References","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Ehrlén, J., & Eriksson, O. (2000). Dispersal Limitation and Patchy Occupancy in Forest Herbs. Ecology, 81(6), 1667-1674. https://doi.org:https://doi.org/10.1890/0012-9658(2000)081[1667:DLAPOI]2.0.CO;2","category":"page"},{"location":"BetaDiversity/#Beta-Diversity-Functions","page":"Beta Diverisity Functions","title":"Beta Diversity Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Beta diversity is a fundamental concept in ecology that quantifies the variation in species composition between different habitats, plots, or over time. In the context of metacommunity analysis, beta diversity functions help to assess how community composition changes spatially across different locations or temporally within a given location.","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"The beta_diversity functions in MetaCommunityMetrics are adapted from the beta.div.comp function in the R package adespatial. These methods, originally developed by Pierre Legendre (2014), are implemented in Julia to provide a more efficient means of computation for large-scale datasets. The functions use indices from the Podani family, Jaccard-based indices, and Ruzicka-based indices to calculate total beta diversity and its components: replacement and richness difference.","category":"page"},{"location":"BetaDiversity/#Choosing-the-Right-Function","page":"Beta Diverisity Functions","title":"Choosing the Right Function","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Use beta_diversity for a general, comprehensive measure of beta diversity across your dataset. This function provides an overall assessment of how species composition varies between sites or over time, capturing both replacement (the turnover of species) and richness difference(the difference in species richness). \nOpt for mean_spatial_beta_div when your focus is on comparing diversity between different spatial locations. \nOpt for mean_temporal_beta_div to track how diversity changes over time within the same location. ","category":"page"},{"location":"BetaDiversity/#The-Functions","page":"Beta Diverisity Functions","title":"The Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"beta_diversity\nmean_spatial_beta_div\nmean_temporal_beta_div","category":"page"},{"location":"BetaDiversity/#MetaCommunityMetrics.beta_diversity","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative data.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a sample and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects how many species are different in one site compared to another, ignoring the species that are mere additions or subtractions.\nRichDif: Richness difference component of diversity, which captures the disparity in biodiversity in terms of the count of species present, without taking into account the specific identities or distributions of those species.\n\nDetails\n\nEmpty patches have to be removed before calculation.\nSpecies that were not recorded at the given time step have to be removed before calculation.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> matrix_with_abundance =  @pipe df |>\n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           select(_, Not(:Presence)) |>\n           unstack(_, :Species, :Abundance, fill=0) |>\n           select(_, Not(:Year, :Month, :Day, :Sampling_date_order, :plot, :Longitude, :Latitude)) |> \n           Matrix(_) |> \n           x -> x[:, sum(x, dims=1)[1, :] .!= 0] |> \n           x -> x[vec(sum(x, dims=2)) .!= 0, :]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 2  0  0  0  0\n 1  0  0  1  0\n 4  0  0  1  0\n 1  0  0  0  0\n 0  1  0  0  1\n 0  0  0  1  0\n 0  0  0  2  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> matrix_with_presence = @pipe df |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           select(_, Not(:Abundance)) |>\n           unstack(_, :Species, :Presence, fill=0) |> #convert it back to the wide format \n           select(_, Not(:Year, :Month, :Day, :Sampling_date_order, :plot, :Longitude, :Latitude)) |> \n           Matrix(_) |>     \n           x -> x[:, sum(x, dims=1)[1, :] .!= 0]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  1  0\n 1  0  0  1  0\n 1  0  0  0  0\n 0  1  0  0  1\n 0  0  0  1  0\n 0  0  0  1  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> result_using_abanduce_data_1 = beta_diversity(matrix_with_abundance; quant=true)\n1×3 DataFrame\n Row │ BDtotal   Repl     RichDif  \n     │ Float64   Float64  Float64  \n─────┼─────────────────────────────\n   1 │ 0.390317   0.2678  0.122517\n\njulia> result_using_abanduce_data_2 = beta_diversity(matrix_with_abundance; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\njulia> result_using_binary_data = beta_diversity(matrix_with_presence; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.mean_spatial_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.mean_spatial_beta_div","text":"mean_spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool) -> DataFrame\n\nCalculate the mean spatial beta diversity components of a metacommunity over time based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the mean values of total beta diversity, replacement, and richness difference components across all time points. Columns are mean_spatial_BDtotal, mean_spatial_Repl, and mean_spatial_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each time step.\nThis function will remove the empty patches before calculating beta diversity.\nThis function will remove species that were not recorded at the given time step before calculating beta diversity.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> result_using_abanduce_data_1 = mean_spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ mean_spatial_BDtotal  mean_spatial_Repl  mean_spatial_RichDif \n     │ Float64               Float64            Float64              \n─────┼───────────────────────────────────────────────────────────────\n   1 │             0.353812           0.168584              0.185228\n        \njulia> result_using_abanduce_data_2 = mean_spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ mean_spatial_BDtotal  mean_spatial_Repl  mean_spatial_RichDif \n     │ Float64               Float64            Float64              \n─────┼───────────────────────────────────────────────────────────────\n   1 │             0.309073            0.16386              0.145214  \n\njulia> result_using_binary_data = mean_spatial_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ mean_spatial_BDtotal  mean_spatial_Repl  mean_spatial_RichDif \n     │ Float64               Float64            Float64              \n─────┼───────────────────────────────────────────────────────────────\n   1 │             0.309073            0.16386              0.145214\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.mean_temporal_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.mean_temporal_beta_div","text":"mean_temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool) -> DataFrame\n\nCalculate the mean temporal beta diversity components acorss all patches based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the mean values of total beta diversity, replacement, and richness difference components across all pactches. Columns are mean_temporal_BDtotal, mean_temporal_Repl, and mean_temporal_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each patch.\nThis function will remove the empty patches before calculating beta diversity.\nThis function will remove species that were not recorded at the given time step before calculating beta diversity.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n\njulia> result_using_abanduce_data_1 = mean_temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ mean_temporal_BDtotal  mean_temporal_Repl  mean_temporal_RichDif \n     │ Float64                Float64             Float64               \n─────┼──────────────────────────────────────────────────────────────────\n   1 │               0.37186            0.152416               0.219444\n        \njulia> result_using_abanduce_data_2 = mean_temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ mean_temporal_BDtotal  mean_temporal_Repl  mean_temporal_RichDif \n     │ Float64                Float64             Float64               \n─────┼──────────────────────────────────────────────────────────────────\n   1 │              0.313244            0.139936               0.173309\n\njulia> result_using_binary_data = mean_temporal_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ mean_temporal_BDtotal  mean_temporal_Repl  mean_temporal_RichDif \n     │ Float64                Float64             Float64               \n─────┼──────────────────────────────────────────────────────────────────\n   1 │              0.313244            0.139936               0.173309\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#References","page":"Beta Diverisity Functions","title":"References","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Legendre, P. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography 23, 1324-1334 (2014). https://doi.org:https://doi.org/10.1111/geb.12207","category":"page"},{"location":"VariabilityMetrics/#Variability-Metrics-Functions","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics functions in MetaCommunityMetrics are designed to capture changes in dispersal and density-dependent biotic interactions by investigating temporal variability and synchrony across spatial scales and organizational levels within a metacommunity. These functions are based on the work of Wang et al. (2019), which provides a framework for quantifying variability at different scales and contexts within a community.","category":"page"},{"location":"VariabilityMetrics/#Overview","page":"Variability Metrics Functions","title":"Overview","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In MetaCommunityMetrics, the CV_meta_simple function is directly adapted from the R function var.partition in Wang et al. (2019). This function is designed with computational efficiency in mind, particularly for large datasets, by avoiding the calculation of all covariances between species. This approach ensures faster performance while still providing valuable insights into variability across different scales within a metacommunity.","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In contrast, the CV_meta function extends the analysis by including the calculation of all covariances between species, offering a more detailed and comprehensive examination of variability. This approach captures interactions between species that may be overlooked by more streamlined methods. While the CV_meta function provides a richer analysis, the CV_meta_simple function remains a valuable tool when computational efficiency is a priority.","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"These metrics are designed to quantify variability at different scales and contexts within the community:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Local-scale average species variability (CV_s_l)\nRegional-scale average species variability (CV_s_r)\nLocal-scale average community variability (CV_c_l)\nRegional-scale community variability (CV_c_r)","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics are calculated as follows:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics CV_s_l, CV_s_r, CV_c_l, and CV_c_r are set to zero whenever the mean abundance equals zero at any combination of spatial scales (a patch/all patches) and species number (a species/the whole community). This approach allows us to assess the impact of spatial scale on variability and to understand how different factors influence community dynamics across scales.","category":"page"},{"location":"VariabilityMetrics/#The-Function","page":"Variability Metrics Functions","title":"The Function","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"CV_meta\nCV_meta_simple","category":"page"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta","text":"CV_meta(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates various coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nDetails This function calculates the coefficients of variation (CV) for species and community biomass at both local and regional scales. The calculation involves several steps:\n\nReorganization of Data: The input data is organized into a DataFrame with columns for abundance, time, plot, and species.\nMean Calculations: Temporal mean species abundance is calculated for each species in each patch, as well as the overall temporal mean biomass.\nTemporal Variance Calculations: Temporal variance is calculated for each species within patches, for species across patches, for the community biomass within patches, and for the overall metacommunity biomass.\nCV Calculations: The coefficients of variation are calculated for species and community biomass at both local and regional scales.\nOutput: The results are returned in a DataFrame summarizing the CVs for local and regional scales.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data() |>\n                          filter(row -> row[:Sampling_date_order] < 20, _)\n6764×10 DataFrame\n  Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n      │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n──────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n    2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n    3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n    4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n    5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n  ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 6760 │  2012      1     21                   19     21  SH               0         0      36.5     -109.0\n 6761 │  2012      1     21                   19      5  SH               0         0      35.0     -108.0\n 6762 │  2012      1     21                   19      7  SH               0         0      35.5     -110.0\n 6763 │  2012      1     21                   19     23  SH               0         0      36.5     -108.0\n 6764 │  2012      1     21                   19     24  SH               0         0      36.5     -107.5\n                                                                                          6754 rows omitted\n                                                                                          \njulia> CV_summary_df = CV_meta(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.05607  0.813324  0.656184  0.537299\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta_simple","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta_simple","text":"CV_meta_simple(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity, using a simpler approach optimized for handling larger datasets.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nDetails This function is a simplified version of the CV_meta function, designed to efficiently handle larger datasets by avoiding complex covariance calculations. The steps include:\n\nReorganization of Data: The input data is organized into a DataFrame with columns for abundance, time, plot, and species, and then transformed into a 3D abundance matrix.\nTotal Abundance Calculations: The function calculates total abundances for species across time, within each patch, and for the entire metacommunity.\nStandard Deviation (SD) Calculations: Temporal standard deviations of abundance are computed for the entire metacommunity, each patch, and each species.\nCV Calculations: The coefficients of variation are calculated for species and community biomass at both local and regional scales.\nOutput: The results are returned in a DataFrame summarizing the CVs for local and regional scales.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data() |>\n                          filter(row -> row[:Sampling_date_order] < 20, _)\n6764×10 DataFrame\n  Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n      │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n──────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n    2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n    3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n    4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n    5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n  ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 6760 │  2012      1     21                   19     21  SH               0         0      36.5     -109.0\n 6761 │  2012      1     21                   19      5  SH               0         0      35.0     -108.0\n 6762 │  2012      1     21                   19      7  SH               0         0      35.5     -110.0\n 6763 │  2012      1     21                   19     23  SH               0         0      36.5     -108.0\n 6764 │  2012      1     21                   19     24  SH               0         0      36.5     -107.5\n                                                                                          6754 rows omitted\n\njulia> CV_summary_df = CV_meta_simple(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.20808  0.918862  0.801216  0.665082\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#References","page":"Variability Metrics Functions","title":"References","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290","category":"page"},{"location":"Benchmarking/#Benchmarking-Results","page":"Benchmarking Results","title":"Benchmarking Results","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"Benchmarking/#Computational-Resources","page":"Benchmarking Results","title":"Computational Resources","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"All benchmarks were performed on the same machine to ensure consistent comparisons.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"CPU: Apple M1 Pro\nNumber of Cores: 10\nMemory: 16GB RAM\nOperating System: macOS Sonoma Version 14.2.1\nJulia Version: 1.9.3\nR Version: 4.3.1","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"Below is a comparison of the benchmarking results between my Julia package and functions/equivalent implmentation in R.","category":"page"},{"location":"Benchmarking/#Direct-Comparison-(When-an-equivalent-fuction-in-R-is-avaliable)","page":"Benchmarking Results","title":"Direct Comparison (When an equivalent fuction in R is avaliable)","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"Test Case Julia Execution Time R Execution Time Speedup (Julia/R) Memory Usage (Julia) Memory Usage (R)\nbetadiversity1 0.118 2.248 19x 0.132 0.057\nbetadiversity2 0.039 0.270 7x 0.133 0.125\nbetadiversity3 0.038 0.280 7x 0.133 0.125\nDNCImultigroupresult 188.369   816.60 ","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"Note: All times are in millisecond, and memory is in mebibytes (MiB). Speedup is calculated as the ratio of R execution time to Julia execution time and rounded to the nearest integer. The test case names are assigned according to the object names used for the benchmarking results. The same object name is used for the same test case between Julia and R for consistency. The same data input are used for each test case.","category":"page"},{"location":"Benchmarking/#Self-Benchmarking-(For-Julia-Only-Functions)","page":"Benchmarking Results","title":"Self-Benchmarking (For Julia-Only Functions)","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"These functions are unique to the Julia package and do not have equivalents in R. We provide benchmarks in terms of execution time and memory usage as a point of comparison for future work or potential replication in other languages.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"Test Case Julia Execution Time Memory Usage (Julia) Data Size (row, column)\nmeanspatialbetadiv1 632.693 239.660 48735, 10\nmeanspatialbetadiv2 625.321 213.450 48735, 10\nmeanspatialbetadiv3 623.162 213.450 48735, 10\nmeantemporalbetadiv1 623.162 213.450 48735, 10\nmeantemporalbetadiv2 141.001 76.520 48735, 10\nmeantemporalbetadiv3 141.477 76.520 48735, 10\ncluster_result 1.491 860.280 2565, 5\nplotclustersresult 2.852 816.600 15, 3\nnicheoverlapresult 6823.000 118.280 48735, 4","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Results","title":"Benchmarking Results","text":"Note: All times are in millisecond, and memory is in mebibytes (MiB).","category":"page"},{"location":"DNCI/#Dispersal-Niche-Continuum-Index-(DNCI)-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The Dispersal-Niche Continuum Index (DNCI) functions in MetaCommunityMetrics quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. The function DNCI_multigroup  in this package is adapted from the R package DNCImper: Assembly process identification based on SIMPER analysis. These methods, originally developed by Clarke(1993) and later refined by Gibert & Escarguel(2019) and Vilmi et al.(2021), offer powerful tools for identifying the processes underlying species assembly in metacommunities. ","category":"page"},{"location":"DNCI/#Background","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Background","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions is built around the Per-SIMPER and DNCI analyses. PerSIMPER, based on the Similarity Percentage (SIMPER) analysis developed by Clarke (1993), assesses the contribution of individual taxa to overall dissimilarity (OAD) between groups of assemblages. PerSIMPER enhances this by comparing empirical SIMPER plots with randomized plots generated through matrix permutation, which helps identify whether niche, dispersal, or both processes are driving community assembly.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI (Dispersal-Niche Continuum Index) further extends this approach by transforming the qualitative results of PerSIMPER into a quantitative index, providing a straightforward measure of the influence of niche and dispersal processes on community structure.","category":"page"},{"location":"DNCI/#Functionality-Overview","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Functionality Overview","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions in MetaCommunityMetrics allow you to analyze the processes driving species assembly within your dataset. By comparing empirical data with randomized permutations, one can determine the extent to which niche and dispersal processes influence the structure of metacommunities. Before calculating the DNCI, groupings of sites (clusters) are required, as the DNCI relies on analyzing community composition across spatial groups. This package provides a function to perform the necessary clustering, which is not available in the equivalent R package. When the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. In contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. If the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.","category":"page"},{"location":"DNCI/#The-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"The Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"create_clusters: Groups sampling locations based on their spatial attributes and species richness, which can then be used to assess DNCI.\nplot_clusters: Visualizes the clusters created, allowing for an intuitive understanding of spatial groupings.\nDNCI_multigroup: Computes the Dispersal-Niche Continuum Index (DNCI) across multiple groups, helping to quantify the relative influence of niche versus dispersal processes.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"create_clusters\nplot_clusters","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.create_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int}, total_richness::Vector{Int}) -> Dict{Int, DataFrame}\n\nThis function creates clusters (groupings of patches/sites) for each unique time step in a dataset which can then used for calculating DNCI. Only presnece-absence data can be used. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ntime::Vector: A vector indicating the time each sample was taken.\nlatitude::Vector: A vector indicating the latitude of each sample.\nlongitude::Vector: A vector indicating the longitude of each sample.\npatch::Vector: A vector indicating the spatial location (patch) of each sample. At least 10 patches are required for clustering.\ntotal_richness::Vector: A vector indicating the total species richness at each plot at each time step.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key represents a unique time point from the input data, with the corresponding value being a DataFrame for that time step. Each DataFrame contains the following columns: Time, Latitude, Longitude, Patch, Total_Richness, and Group (indicating the assigned cluster).\n\nDetails This function performs hierarchical clustering on the geographical coordinates of sampling patches/sites at each unique time step, assuming that organism dispersal occurs within the study region. It incorporates checks and adjustments to ensure the following conditions are met: at least 2 clusters, a minimum of 5 patches/sites per cluster, and that the variation in the number of taxa/species and patches/sites per group does not exceed 40% and 30%, respectively. These conditions are critical for calculating an unbiased DNCI value, and the function will issue warnings if any are not fulfilled.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n15×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      35.0     -108.0      5               0      2\n  15 │     1      36.5     -108.0     23               1      2\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#MetaCommunityMetrics.plot_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(latitude::Vector{Float64}, longitude::Vector{Float64}, group::Union{AbstractVector, String})\n\nPlots the clustering result at one time step of the create_cluster function using the geographic coordinates and cluster assignments of patches/sites.\n\nArguments\n\nlatitude::Vector{Float64}: A vector of latitude coordinates of the patches/sites.\nlongitude::Vector{Float64}: A vector of longitude coordinates of the patches/sites.\ngroup::Union{AbstractVector, String}: A vector or string indicating the cluster assignments for each data point.\n\nReturns\n\nA plot showing the patches/sites colored by the cluster assignment from the create_clusters function.\n\nDetails\n\nThe function assigns a unique color to each cluster and plots the patches/sites based on their geographic coordinates.\nThe patches/sites are colored according to the cluster assignment.\nThe plot includes black borders around the markers for better visibility.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n15×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      35.0     -108.0      5               0      2\n  15 │     1      36.5     -108.0     23               1      2\n\njulia> plot_clusters(result[1].Latitude, result[1].Longitude, result[1].Group)\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"This plot shows the clustering result for time step 1 based on geographic coordinates: (Image: Cluster Plot)","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"DNCI_multigroup","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.DNCI_multigroup","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000; count::Bool=true) -> DataFrame\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021). The DNCI quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix. You can use the create_clusters function to generate the group membership.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\ncount::Bool=true: A flag indicating whether the numeber of permutations is printed. Default is false.\n\nReturns\n\nDataFrame: A DataFrame containing the DNCI value, the associate confiden interval (CI_DNCI) and variance (S_DNCI) for each pair of groups.\n\nDetails\n\nThe function calculates the DNCI for each pair of groups in the input data.\nWhen the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. \nIn contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. \nIf the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.\nPlease remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted   \n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n15×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      35.0     -108.0      5               0      2\n  15 │     1      36.5     -108.0     23               1      2\n\njulia> comm= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  filter(row -> row[:Sampling_date_order] == 1, _) |>\n                  select(_, [:plot, :Species, :Presence]) |>\n                  unstack(_, :Species, :Presence, fill=0) |>\n                  select(_, Not(:plot)) |>\n                  Matrix(_)\n15×3 Matrix{Int64}:\n 1  0  0\n 1  0  0\n 1  0  0\n 1  0  0\n 1  1  0\n 1  1  0\n 1  0  0\n 0  0  1\n 0  1  0\n 0  1  0\n 1  0  0\n 0  1  0\n 0  0  1\n 0  0  0\n 0  0  1\n\njulia> result = DNCI_multigroup(comm, clustering_result[1].Group, 1000; count = false)\n1×5 DataFrame\n Row │ group1  group2  DNCI       CI_DNCI  S_DNCI  \n     │ Int64   Int64   Float64    Float64  Float64 \n─────┼─────────────────────────────────────────────\n   1 │      1       2  -0.836142  5.02335  2.51167\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#References","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"References","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"Clarke, K. R. Non-parametric multivariate analyses of changes in community structure. Australian Journal of Ecology 18, 117-143 (1993). https://doi.org:https://doi.org/10.1111/j.1442-9993.1993.tb00438.x\nGibert, C. & Escarguel, G. PER-SIMPER—A new tool for inferring community assembly processes from taxon occurrences. Global Ecology and Biogeography 28, 374-385 (2019). https://doi.org:https://doi.org/10.1111/geb.12859\nVilmi, A. et al. Dispersal–niche continuum index: a new quantitative metric for assessing the relative importance of dispersal versus niche processes in community assembly. Ecography 44, 370-379 (2021). https://doi.org:https://doi.org/10.1111/ecog.05356","category":"page"},{"location":"NicheOverlapIndex/#Niche-Overlap-Index-Function","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"CurrentModule = MetaCommunityMetrics","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"Niche overlap refers to the extent to which different species use the same resources or occupy similar ecological niches. High niche overlap might indicate intense competition, whereas low overlap suggests niche differentiation, allowing species to coexist by minimizing direct competition.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"To capture the changes in density-independent abiotic response, also known as niche breadth, this implementation uses Pianka's Niche Overlap Index, as suggested by Pianka (1973). The summary statistics of this index include the mean, maximum, and minimum values across all species pairs, providing a comprehensive understanding of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/#Functionality-Overview","page":"Niche Overlap Index Function","title":"Functionality Overview","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"The Niche Overlap Index functions in MetaCommunityMetrics provide a robust framework for calculating niche overlap based on species abundance or presence-absence data. These functions allow you to evaluate how species share ecological space within a metacommunity, offering valuable insights into community dynamics and species interactions.","category":"page"},{"location":"NicheOverlapIndex/#The-Function","page":"Niche Overlap Index Function","title":"The Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"niche_overlap: This function calculates the Niche Overlap Index for a given set of species across different patches. It provides metrics for mean, minimum, and maximum niche overlap, allowing for a comprehensive assessment of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"niche_overlap","category":"page"},{"location":"NicheOverlapIndex/#MetaCommunityMetrics.niche_overlap","page":"Niche Overlap Index Function","title":"MetaCommunityMetrics.niche_overlap","text":"niche_overlap(abundance::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}, time::AbstractVector) -> DataFrame\n\nCalculates the overall mean, maximum, and minimum values of the niche overlap index from all species pairs in the provided data.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\nspecies::Union{AbstractVector, String}: Vector or string representing species names or IDs.\npatch::Union{AbstractVector, String}: Vector or string representing patch names or IDs.\ntime::AbstractVector: Vector representing the time points.\n\nDescription\n\nThe niche overlap index is calculated based on the method suggested by Pianka (1973), with the assumption that the proportional use of a species at a specific site and time equals its relative abundance at that site and time. To determine relative abundance, the abundance of each species in a particular patch is divided by the total abundance of that species across all patches and times.\n\nReturns\n\nDataFrame: A DataFrame containing the overall mean, maximum, and minimum values of the niche overlap index from all species pairs.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48725 rows omitted\n                                                                                          \njulia> result = niche_overlap(df.Abundance, df.Species, df.plot, df.Sampling_date_order)\n1×3 DataFrame\n Row │ mean_niche_overlap_index  min_niche_overlap_index  max_niche_overlap_index \n     │ Float64                   Float64                  Float64                 \n─────┼────────────────────────────────────────────────────────────────────────────\n   1 │                 0.827739                 0.591836                      1.0\n\n\n\n\n\n","category":"function"},{"location":"NicheOverlapIndex/#References","page":"Niche Overlap Index Function","title":"References","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"MacArthur, R. & Levins, R. The limiting similarity, convergence, and divergence of coexisting species. The American Naturalist 101, 377-385 (1967). \nPianka, E. R. (1974). \"Niche overlap and diffuse competition.\" Proceedings of the National Academy of Sciences, 71(5), 2141-2145.\nPianka, E. R. (1973). \"The Structure of Lizard Communities.\" Annual Review of Ecology and Systematics, 4(1), 53-74.","category":"page"},{"location":"#MetaCommunityMetrics.jl","page":"Home","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of tools and utilities for analyzing meta-communities in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#An-Overview","page":"Home","title":"An Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a comprehensive toolkit designed to characterize the spatiotemporal structure and dynamics of a metacommunity—a network of communities linked by the dispersal of multiple, interacting species, each with unique niche breadths. It includes functions to calculate a range of specific metrics, which have been previously implemented in R and proven valuable for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, they come with high computational costs, especially for large species community datasets. To address this issue, MetaCommunityMetrics.jl was developed in Julia, a programming language known for its efficiency in handling computationally intensive tasks. This implementation significantly improves the efficiency of calculating these metrics, making it a powerful tool for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Averaged beta diversity decomposition in space/time: total diversity, species replacement (turnover), and richness differences for both presence-absence and abundance data\nDispersal-niche continuum index to evaluate the degree to which communities are influenced by dispersal processes and niche breadth\nNiche overlap indices to determine the extent of niche sharing among species within the metacommunity\nThe proportion of habitat patches occupied by each species\nThe variability of community composition across different spatial and temporal scales","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"MetaCommunityMetrics\")\n\nusing MetaCommunityMetrics","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta Diversity\nDNCI\nNiche Overlap Index\nOccupied Patches Proportion\nVariability Metrics","category":"page"},{"location":"#Accessing-the-Sample-Data-for-exploring-the-functions","page":"Home","title":"Accessing the Sample Data for exploring the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes rodent data from the Portal Project, a long-term study of a Chihuahuan desert ecosystem (available at https://github.com/weecology/portalr), as sample data for testing and benchmarking functions between Julia and R. The original rodent abundance data were collected monthly across 24 plots, recording a total of 24 species. For the purposes of this package, the data are filtered for the period from 2010 to 2023, transformed into long format, and species that were not recorded during this period are removed. Additionally, plots with no observations at a given time step are excluded. A new column, Sampling_date_order, was created to sequentially number the sampling dates, starting at 1 and continuing through 117, to facilitate analysis. The locations of the plots (Latitude and Longitude) were simulated for testing the DNCI functions. The scripts to download and wrangle the data can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Downloading the rodent data\nData Wrangling","category":"page"},{"location":"","page":"Home","title":"Home","text":"To assess the sample data, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MetaCommunityMetrics\n\nload_sample_data()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using MetaCommunityMetrics\n\njulia> load_sample_data()\n48735×10 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64   \n───────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5\n     3 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5\n     4 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0\n     5 │  2010      1     16                    1     11  BA               0         0      35.5     -108.0\n     6 │  2010      1     16                    1     14  BA               0         0      36.0     -109.5\n     7 │  2010      1     16                    1     17  BA               0         0      36.0     -108.0\n     8 │  2010      1     16                    1     22  BA               0         0      36.5     -108.5\n     9 │  2010      1     16                    1      6  BA               0         0      35.0     -107.5\n    10 │  2010      1     16                    1     13  BA               0         0      36.0     -110.0\n    11 │  2010      1     16                    1     15  BA               0         0      36.0     -109.0\n    12 │  2010      1     16                    1     20  BA               0         0      36.5     -109.5\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮\n 48725 │  2023      3     21                  117     15  SH               1         1      36.0     -109.0\n 48726 │  2023      3     21                  117     19  SH               0         0      36.5     -110.0\n 48727 │  2023      3     21                  117     20  SH               0         0      36.5     -109.5\n 48728 │  2023      3     21                  117     21  SH               0         0      36.5     -109.0\n 48729 │  2023      3     21                  117     22  SH               0         0      36.5     -108.5\n 48730 │  2023      3     21                  117      1  SH               0         0      35.0     -110.0\n 48731 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0\n 48732 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5\n 48733 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5\n 48734 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5\n 48735 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0\n                                                                                          48712 rows omitted","category":"page"}]
}
