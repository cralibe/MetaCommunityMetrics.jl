var documenterSearchIndex = {"docs":
[{"location":"NicheOverlapIndex/#Niche-Overlap-Index-Function","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"Niche overlap refers to the extent to which different species use the same resources or occupy similar ecological niches. High niche overlap might indicate intense competition, whereas low overlap suggests niche differentiation, allowing species to coexist by minimizing direct competition.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"To capture the changes in density-independent abiotic response, also known as niche breadth, this implementation uses Pianka's Niche Overlap Index, as suggested by Pianka (1973). The summary statistics of this index include the mean, maximum, and minimum values across all species pairs, providing a comprehensive understanding of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/#Functionality-Overview","page":"Niche Overlap Index Function","title":"Functionality Overview","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"The Niche Overlap Index functions in MetaCommunityMetrics provide a robust framework for calculating niche overlap based on species abundance or presence-absence data. These functions allow you to evaluate how species share ecological space within a metacommunity, offering valuable insights into community dynamics and species interactions.","category":"page"},{"location":"NicheOverlapIndex/#The-Function","page":"Niche Overlap Index Function","title":"The Function","text":"","category":"section"},{"location":"NicheOverlapIndex/#MetaCommunityMetrics.niche_overlap","page":"Niche Overlap Index Function","title":"MetaCommunityMetrics.niche_overlap","text":"niche_overlap(abundance::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}, time::AbstractVector) -> DataFrame\n\nCalculates the overall mean, maximum, and minimum values of the niche overlap index from all species pairs in the provided data.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\nspecies::Union{AbstractVector, String}: Vector or string representing species names or IDs.\npatch::Union{AbstractVector, String}: Vector or string representing patch names or IDs.\ntime::AbstractVector: Vector representing the time points.\n\nDescription\n\nThe niche overlap index is calculated based on the method suggested by Pianka (1973), with the assumption that the proportional use of a species at a specific site and time equals its relative abundance at that site and time. To determine relative abundance, the abundance of each species in a particular patch is divided by the total abundance of that species across all patches and times.\n\nReturns\n\nDataFrame: A DataFrame containing the overall mean, maximum, and minimum values of the niche overlap index from all species pairs.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> result = niche_overlap(df.Abundance, df.Species, df.plot, df.Sampling_date_order)\n1×3 DataFrame\n Row │ mean_niche_overlap_index  min_niche_overlap_index  max_niche_overlap_index \n     │ Float64                   Float64                  Float64                 \n─────┼────────────────────────────────────────────────────────────────────────────\n   1 │                 0.827739                 0.591836                      1.0\n\n\n\n\n\n","category":"function"},{"location":"NicheOverlapIndex/#References","page":"Niche Overlap Index Function","title":"References","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"MacArthur, R. & Levins, R. The limiting similarity, convergence, and divergence of coexisting species. The American Naturalist 101, 377-385 (1967). \nPianka, E. R. (1974). \"Niche overlap and diffuse competition.\" Proceedings of the National Academy of Sciences, 71(5), 2141-2145.\nPianka, E. R. (1973). \"The Structure of Lizard Communities.\" Annual Review of Ecology and Systematics, 4(1), 53-74.","category":"page"},{"location":"Validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"We validate all the calcuations in MetaCommunityMetrics that have equvilant functions in R to make sure the functions in MetaCommunityMetrics are correct and accurate as the equvilant functions in R. All validation results are presented to 4 decimal places (±0.0001) here. Floating-point differences between implementations smaller than 0.0001 were considered negligible for both statistical and ecological applications of these metrics.","category":"page"},{"location":"Validation/#Validation-Result","page":"Validation","title":"Validation Result","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Below is a comparison of the results between MetaCommunityMetrics and functions/equivalent implementation in R.","category":"page"},{"location":"Validation/#Beta-Diversity","page":"Validation","title":"Beta Diversity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here. All values *","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"TestCase BDtotal Repl RichDif\nBeta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nBeta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nBeta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Dispersal-niche-continuum-index","page":"Validation","title":"Dispersal-niche continuum index","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*A plot showing the distribution of the DNCI values of diffent group pairs from different programming language, each pair are runned for 100 times. (Image: Julia vs. R)","category":"page"},{"location":"Validation/#Occupied-Patches-Proportion","page":"Validation","title":"Occupied Patches Proportion","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"minproppatches meanproppatches maxproppatches\n0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Variability-Metrics","page":"Validation","title":"Variability Metrics","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"CVSL CVCL CVSR CVCR\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Hypervolume","page":"Validation","title":"Hypervolume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/#Volume","page":"Validation","title":"Volume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"total correlation Temperature Precipitation\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Volume-dissimilarity","page":"Validation","title":"Volume dissimilarity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Metric total correlation Temperature Precipitation\nBhattacharyya_distance 0.0000 0.0000 0.0000 0.0000\nMahalanobis_distance 0.0000 0.0000 0.0000 0.0000\nDeterminant_ratio 0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Running-Validation","page":"Validation","title":"Running Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"The script to run this validation result can be found here.","category":"page"},{"location":"OccupiedPatchesProportion/#Occupied-Patches-Proportion-Function","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion function in MetaCommunityMetrics provides a simple yet powerful metric for understanding the distribution and prevalence of species across different habitat patches within a metacommunity. By calculating the averaged, minmum and maximum proportion of patches occupied across species, this function helps ecologists assess the spatial extent of species distributions and identify potential patterns of rarity or commonness across the landscape.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"This function draws on the concepts discussed by Ehrlén & Eriksson (2000) in their study on dispersal limitation and patchy occupancy in forest herbs. According to their findings, low occupancy may indicate dispersal limitation or strong competition, while high occupancy could suggest mass effects due to high dispersal rates or the ability to thrive in various conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#An-Overview","page":"Occupied Patches Proportion Function","title":"An Overview","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion metric quantifies the averaged proportion of habitat patches in which a species is present. This information is crucial for understanding species distributions, particularly in fragmented landscapes or patchy environments where species may not occupy all available habitat. This metric can be used to identify widespread species, which occupy a large number of patches, as well as rare species, which are restricted to only a few patches.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"After calculating the proportion of patches occupied for each species, the mean, minimum, and maximum proportion of patches occupied can be derived. These values are valuable indicators of ecological processes:","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Low proportion of patches occupied: May indicate dispersal limitation or strong competition among species. Such patterns could suggest that certain species struggle to colonize or persist in many patches.\nHigh proportion of patches occupied: May point to mass effects, where species are abundant in many patches, possibly due to high dispersal rates or the ability to thrive across a range of conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#The-Function","page":"Occupied Patches Proportion Function","title":"The Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/#MetaCommunityMetrics.prop_patches","page":"Occupied Patches Proportion Function","title":"MetaCommunityMetrics.prop_patches","text":"prop_patches(presence::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}) -> DataFrame\n\nCalculate the proportion of patches occupied by each species and summarize the results.\n\nThis function takes three vectors: presence, species, and patch, and performs the following steps:\n\nArguments\n\npresence::AbstractVector: A vector indicating the presence (1) or absence (0) of a species in a patch.\nspecies::Union{AbstractVector, String}: A vector of species names.\npatch::Union{AbstractVector, String}: A vector of patch identifiers.\n\nReturns\n\nDataFrame: A DataFrame containing the mean, minimum, and maximum proportion of patches               occupied across all species.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n                                                                                          \njulia> prop_patches(df.Presence, df.Species, df.plot)\n1×3 DataFrame\n Row │ mean_prop_patches  min_prop_patches  max_prop_patches \n     │ Float64            Float64           Float64          \n─────┼───────────────────────────────────────────────────────\n   1 │          0.734649         0.0833333               1.0\n\n\n\n\n\n","category":"function"},{"location":"OccupiedPatchesProportion/#References","page":"Occupied Patches Proportion Function","title":"References","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Ehrlén, J., & Eriksson, O. (2000). Dispersal Limitation and Patchy Occupancy in Forest Herbs. Ecology, 81(6), 1667-1674. https://doi.org:https://doi.org/10.1890/0012-9658(2000)081[1667:DLAPOI]2.0.CO;2","category":"page"},{"location":"#MetaCommunityMetrics.jl","page":"Home","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of tools and utilities for analyzing meta-communities in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#An-Overview","page":"Home","title":"An Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a comprehensive toolkit designed to characterize the spatiotemporal structure and dynamics of a metacommunity—a network of communities linked by the dispersal of multiple, interacting species, each with unique niche breadths. It includes functions to calculate a range of specific metrics, which have been previously implemented in R and proven valuable for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, they come with high computational costs, especially for large species community datasets. To address this issue, MetaCommunityMetrics.jl was developed in Julia, a programming language known for its efficiency in handling computationally intensive tasks. This implementation significantly improves the efficiency of calculating these metrics, making it a powerful tool for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beta diversity decompositions in space/time: total diversity, species replacement (turnover), and richness differences for both presence-absence and abundance data\nDispersal-niche continuum index to evaluate the degree to which communities are influenced by dispersal processes and niche breadth\nNiche overlap indices to determine the extent of niche sharing among species within the metacommunity\nThe proportion of habitat patches occupied by each species\nThe variability of community composition across different spatial and temporal scales\nNiche hypervolume measurements (individual species, average, and between-species dissimilarities)","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"MetaCommunityMetrics\")\n\nusing MetaCommunityMetrics","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta Diversity\nDNCI\nNiche Overlap Index\nOccupied Patches Proportion\nVariability Metrics\nHypervolume","category":"page"},{"location":"#Comparison-between-Julia-and-R-implementations","page":"Home","title":"Comparison between Julia and R implementations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Validation\nBenchmarking","category":"page"},{"location":"#Accessing-the-Sample-Data-for-exploring-the-functions","page":"Home","title":"Accessing the Sample Data for exploring the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes rodent data from the Portal Project, a long-term study of a Chihuahuan desert ecosystem (available at https://github.com/weecology/portalr), as sample data for testing and benchmarking functions between Julia and R. The original rodent abundance data were collected monthly across 24 plots, recording a total of 21 species. For the purposes of this package, the data are filtered for the period from 2010 to 2023, transformed into long format, and species that were not recorded during this period are removed. Additionally, plots with no observations during the whole sampling period are excluded. A new column, Sampling_date_order, was created to sequentially number the sampling dates, starting at 1 and continuing through 117, to facilitate analysis. The locations of the plots (Latitude and Longitude) were simulated for testing the DNCI functions. The temperature and precipatation data were simulated for testing the hypervolume functions. The scripts to download and wrangle the original data can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Downloading the rodent data\nData Wrangling","category":"page"},{"location":"","page":"Home","title":"Home","text":"To assess the sample data, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MetaCommunityMetrics\n\nload_sample_data()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using MetaCommunityMetrics\n\njulia> load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted","category":"page"},{"location":"#Acknowledgment","page":"Home","title":"Acknowledgment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Acknowledgment","category":"page"},{"location":"BetaDiversity/#Beta-Diversity-Functions","page":"Beta Diverisity Functions","title":"Beta Diversity Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Beta diversity is a fundamental concept in ecology that quantifies the variation in species composition between different plots, or over time. In the context of metacommunity analysis, beta diversity functions help to assess how community composition changes spatially across different locations or temporally within a metacommunity.","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"The beta_diversity functions in MetaCommunityMetrics are adapted from the beta.div.comp function in the R package adespatial. These methods, originally developed by Pierre Legendre (2014), are implemented in Julia to provide a more efficient means of computation for large-scale datasets. The functions use indices from the Podani family, Jaccard-based indices, and Ruzicka-based indices to calculate total beta diversity and its components: replacement and richness difference.","category":"page"},{"location":"BetaDiversity/#Choosing-the-Right-Function","page":"Beta Diverisity Functions","title":"Choosing the Right Function","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Use beta_diversity for a general, comprehensive measure of beta diversity across your dataset. This function provides an overall assessment of how species composition varies between sites or over time, capturing both replacement (the turnover of species) and richness difference(the difference in species richness). \nUse spatial_beta_div to comparing diversity between different spatial locations of a metacommunity. \nUse temporal_beta_div to track how diversity changes over time of a metacommunity. ","category":"page"},{"location":"BetaDiversity/#The-Functions","page":"Beta Diverisity Functions","title":"The Functions","text":"","category":"section"},{"location":"BetaDiversity/#MetaCommunityMetrics.beta_diversity","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative data.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a sample and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects how many species are different in one site compared to another, ignoring the species that are mere additions or subtractions.\nRichDif: Richness difference component of diversity, which captures the disparity in biodiversity in terms of the count of species present, without taking into account the specific identities or distributions of those species.\n\nDetails\n\nEmpty patches have to be removed before calculation.\nSpecies that were not recorded at the given time step have to be removed before calculation.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThis function is a translation/adaptation of the beta.dov.comp function from the R package adespatial,licensed under GPL-3.\nOriginal package and documentation available at: https://cran.r-project.org/web/packages/adespatial/index.html\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String   Int64      Int64     Float64   Float64    Float64?                Float64?                 \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> matrix_with_abundance = @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :normalized_temperature, :normalized_precipitation, :Presence)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           unstack(_, :Species, :Abundance, fill=0) |>  \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix\n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:] \n15×5 Matrix{Union{Missing, Int64}}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 2  0  0  0  0\n 1  0  0  1  0\n 4  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  2  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> matrix_with_presence =  @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :normalized_temperature, :normalized_precipitation, :Abundance)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |>\n           unstack(_, :Species, :Presence, fill=0) |> \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix      \n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  1  0\n 1  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  1  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> result_using_abanduce_data_1 = beta_diversity(matrix_with_abundance; quant=true)\n1×3 DataFrame\n Row │ BDtotal   Repl     RichDif  \n     │ Float64   Float64  Float64  \n─────┼─────────────────────────────\n   1 │ 0.390317   0.2678  0.122517\n\njulia> result_using_abanduce_data_2 = beta_diversity(matrix_with_abundance; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\njulia> result_using_binary_data = beta_diversity(matrix_with_presence; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.spatial_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.spatial_beta_div","text":"spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in space based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in space. Columns are spatial_BDtotal, spatial_Repl, and spatial_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components after aggregating .\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in space is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> result_using_abanduce_data_1 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.264822      0.121882         0.142939\n        \njulia> result_using_abanduce_data_2 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\njulia> result_using_binary_data = spatial_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.temporal_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.temporal_beta_div","text":"temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in time based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in time. Columns are temporal_BDtotal, temporal_Repl, and temporal_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each patch.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in time is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> result_using_abanduce_data_1 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.311222      0.0995483          0.211674\n        \njulia> result_using_abanduce_data_2 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\njulia> result_using_binary_data = temporal_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#References","page":"Beta Diverisity Functions","title":"References","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Guzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683\nLegendre, P. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography 23, 1324-1334 (2014). https://doi.org:https://doi.org/10.1111/geb.12207","category":"page"},{"location":"VariabilityMetrics/#Variability-Metrics-Functions","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics functions in MetaCommunityMetrics are designed to capture changes in dispersal and density-dependent biotic interactions by investigating temporal variability and synchrony across spatial scales and organizational levels within a metacommunity. These functions are based on the work of Wang et al. (2019), which provides a framework for quantifying variability at different scales and contexts within a community.","category":"page"},{"location":"VariabilityMetrics/#An-Overview","page":"Variability Metrics Functions","title":"An Overview","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In MetaCommunityMetrics, the CV_meta function is directly adapted from the R function var.partition in Wang et al. (2019).","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The function provides four metrics that are designed to quantify variability at different scales and contexts within a metacommunity:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Local-scale average species variability (CV_s_l)\nRegional-scale average species variability (CV_s_r)\nLocal-scale average community variability (CV_c_l)\nRegional-scale community variability (CV_c_r)","category":"page"},{"location":"VariabilityMetrics/#The-Function","page":"Variability Metrics Functions","title":"The Function","text":"","category":"section"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta","text":"CV_meta(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> CV_summary_df = CV_meta(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.48859  0.944937  0.718266  0.580183\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#References","page":"Variability Metrics Functions","title":"References","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290","category":"page"},{"location":"Acknowledgment/#Acknowledgment","page":"Acknowledgment","title":"Acknowledgment","text":"","category":"section"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package includes translations and adaptations of functions from the R packages adespatial (licensed under GPL-3), vegan (licensed under GPL-2 or later), DNCImper (licensed under GPL-3), and MVNH (licensed under GPL-3). The original packages and their documentation are available at:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"adespatial: https://cran.r-project.org/web/packages/adespatial/index.html\nvegan: https://cran.r-project.org/web/packages/vegan/index.html\nDNCImper: https://github.com/Corentin-Gibert-Paleontology/DNCImper\nMVNH : https://github.com/lvmuyang/MVNH","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package also includes translations and adaptations of functions that are provided by the scripts of these papers:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290\nGuzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Please refer to these sources for full details on the original implementations and licenses.","category":"page"},{"location":"Benchmarking/#Benchmark-Results","page":"Benchmark Results","title":"Benchmark Results","text":"","category":"section"},{"location":"Benchmarking/#Computational-Resources","page":"Benchmark Results","title":"Computational Resources","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"All benchmarks were performed on the same machine to ensure consistent comparisons.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"CPU: Apple M4\nNumber of Cores: 10\nMemory: 16GB RAM\nOperating System: macOS Sequoia 15.5\nJulia Version: 1.10.9\nR Version: 4.4.2","category":"page"},{"location":"Benchmarking/#Benchmarking-Methods","page":"Benchmark Results","title":"Benchmarking Methods","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"To assess the efficiency of MetaCommunityMetrics compared to equivalent R implementations, we benchmark our functions against their R counterparts, focusing on execution time and memory usage. The following tables summarize the benchmark results based on 100 samples each. ","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"We tested using datasets of three sizes:","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Small (5,325 observations)\nMedium (26,676 observations) \nLarge (53,352 observations)","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"The large dataset is the sample data included with MetaCommunityMetrics, accessible via load_sample_data(). The small and medium datasets can be accessed here.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Each function was benchmarked using 100 samples in both BenchmarkTools.jl in Julia and bench::mark() in R to ensure robust statistical sampling. For memory usage comparisons:","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"In Julia, we report the memory estimate from BenchmarkTools.jl, which measures bytes allocated during the trial with minimum elapsed time\nIn R, we report the mem_alloc metric from bench::mark(), which tracks R heap allocations","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"According to documentation, the Julia metric measures total memory allocation during execution, while the R metric specifically tracks heap allocations within the R runtime, excluding \"memory allocated outside the R heap, e.g., by malloc() or new directly.\" Due to differences in language implementation and measurement methodology, direct numerical comparisons between languages should be interpreted with caution.","category":"page"},{"location":"Benchmarking/#Speedup-Summary","page":"Benchmark Results","title":"Speedup Summary","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Below is a plot showing the speedup of all benchmarked functions across the three datasets (small, medium and large). Speedup is calculated as the R median execution time divided by the Julia median execution time. (Image: Speedup Plot)","category":"page"},{"location":"Benchmarking/#Benchmark-Results-in-Details","page":"Benchmark Results","title":"Benchmark Results in Details","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"All times are in millisecond (ms), and memory is in mebibytes (MiB). All values are rounded up to 4 decimal places.","category":"page"},{"location":"Benchmarking/#Median-Execution-time-and-Speedup-Values","page":"Benchmark Results","title":"Median Execution time and Speedup Values","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"95% confidence interval is reported.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase DataSize Julia R Speedup Lower CI Upper CI\nBeta Diversity (Abundance, quant=true) Large 0.1332 4.3445 32.6197 27.5722 36.8202\nBeta Diversity (Abundance, quant=true) Medium 0.0687 2.1992 32.0264 29.0750 33.1992\nBeta Diversity (Abundance, quant=true) Small 0.0378 1.1609 30.7185 29.0248 32.2305\nBeta Diversity (Abundance, quant=false) Large 0.0161 0.4163 25.8141 23.3637 27.4420\nBeta Diversity (Abundance, quant=false) Medium 0.0132 0.3424 25.9220 22.0375 33.5185\nBeta Diversity (Abundance, quant=false) Small 0.0078 0.2515 32.1912 30.8441 35.8422\nBeta Diversity (Presence, quant=false) Large 0.0159 0.3982 25.0176 23.6800 25.7236\nBeta Diversity (Presence, quant=false) Medium 0.0087 0.3823 43.9074 38.6950 49.6426\nBeta Diversity (Presence, quant=false) Small 0.0053 0.2564 48.6391 45.4927 51.1281\nSpatial Beta Diversity (Abundance, quant=true) Large 1.1301 20.2642 17.9316 17.0000 19.2013\nSpatial Beta Diversity (Abundance, quant=true) Medium 0.8479 18.4196 21.7233 19.7421 22.9488\nSpatial Beta Diversity (Abundance, quant=true) Small 0.6572 17.1660 26.1205 24.6700 27.1604\nSpatial Beta Diversity (Abundance, quant=false) Large 1.0138 11.6479 11.4890 10.5726 12.5365\nSpatial Beta Diversity (Abundance, quant=false) Medium 0.7158 12.4047 17.3305 16.6366 18.2021\nSpatial Beta Diversity (Abundance, quant=false) Small 0.5371 11.3735 21.1747 19.9476 22.2527\nSpatial Beta Diversity (Presence, quant=false) Large 1.0038 13.1005 13.0507 12.0992 13.6914\nSpatial Beta Diversity (Presence, quant=false) Medium 0.7014 12.5121 17.8399 17.0997 18.9505\nSpatial Beta Diversity (Presence, quant=false) Small 0.5451 12.7800 23.4451 21.7508 25.2425\nTemporal Beta Diversity (Abundance, quant=true) Large 4.7010 110.1159 23.4240 21.9434 24.7747\nTemporal Beta Diversity (Abundance, quant=true) Medium 4.1895 114.4033 27.3070 25.3973 28.7955\nTemporal Beta Diversity (Abundance, quant=true) Small 3.9819 105.3824 26.4657 24.9444 27.8503\nTemporal Beta Diversity (Abundance, quant=false) Large 1.9144 16.3894 8.5612 7.9902 9.2707\nTemporal Beta Diversity (Abundance, quant=false) Medium 1.2866 18.0571 14.0352 13.4637 15.0241\nTemporal Beta Diversity (Abundance, quant=false) Small 1.0581 16.4432 15.5406 14.9376 16.5922\nTemporal Beta Diversity (Presence, quant=false) Large 1.8345 16.9536 9.2414 8.3232 9.5157\nTemporal Beta Diversity (Presence, quant=false) Medium 1.2635 17.9482 14.2054 13.2281 15.1381\nTemporal Beta Diversity (Presence, quant=false) Small 1.0301 18.9476 18.3931 17.3701 19.2858\nDispersal-niche continuum index Large 148.1271 23881.0763 161.2201 159.2672 163.6917\nDispersal-niche continuum index Medium 55.4244 9162.7688 165.3202 160.2957 168.0416\nDispersal-niche continuum index Small 12.9935 4616.0343 355.2583 342.8383 365.4051\nOccupied Patches Proportion Large 0.9207 15.3826 16.7078 15.4818 17.9102\nOccupied Patches Proportion Medium 0.6746 14.9464 22.1544 20.3012 24.4865\nOccupied Patches Proportion Small 0.2059 11.9799 58.1900 56.3142 62.9279\nVariability Metrics Large 13.6071 289.3605 21.2654 20.4422 22.5900\nVariability Metrics Medium 7.5160 160.1695 21.3103 19.4700 22.7980\nVariability Metrics Small 2.5891 41.8531 16.1652 14.9528 17.4196\nHypervolume Estimation Large 0.0037 0.0484 13.0585 12.2988 13.9432\nHypervolume Estimation Medium 0.0032 0.0414 13.0690 11.7828 13.6907\nHypervolume Estimation Small 0.0030 0.0472 15.6100 14.2913 17.2994\nHypervolume Dissimilarity Large 0.0062 0.1645 26.6729 25.9444 27.6184\nHypervolume Dissimilarity Medium 0.0053 0.1615 30.2791 28.3302 34.3604\nHypervolume Dissimilarity Small 0.0050 0.2097 41.5937 35.4623 51.5496","category":"page"},{"location":"Benchmarking/#Memory-Usage","page":"Benchmark Results","title":"Memory Usage","text":"","category":"section"},{"location":"Benchmarking/#Benchmarked-using-Large-Dataset","page":"Benchmark Results","title":"Benchmarked using Large Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.4346 0.0566\nBeta Diversity (Abundance, quant=false) 0.1347 0.1252\nBeta Diversity (Presence, quant=false) 0.1347 0.1252\nSpatial Beta Diversity (Abundance, quant=true) 3.9185 3.1177\nSpatial Beta Diversity (Abundance, quant=false) 3.5173 2.6747\nSpatial Beta Diversity (Presence, quant=false) 3.5173 2.6747\nTemporal Beta Diversity (Abundance, quant=true) 16.8838 16.8897\nTemporal Beta Diversity (Abundance, quant=false) 5.6586 5.1786\nTemporal Beta Diversity (Presence, quant=false) 5.6586 5.1786\nDispersal-niche continuum index 408.4503 8347.5709\nOccupied Patches Proportion 2.5230 1.8891\nVariability Metrics 12.4573 60.1502\nHypervolume Estimation 0.0122 0.0022\nHypervolume Dissimilarity 0.0168 0.0145","category":"page"},{"location":"Benchmarking/#Benchmarked-using-Medium-Dataset","page":"Benchmark Results","title":"Benchmarked using Medium Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.2491 0.0357\nBeta Diversity (Abundance, quant=false) 0.1086 0.0798\nBeta Diversity (Presence, quant=false) 0.1086 0.0798\nSpatial Beta Diversity (Abundance, quant=true) 2.3897 2.2770\nSpatial Beta Diversity (Abundance, quant=false) 1.9910 1.8340\nSpatial Beta Diversity (Presence, quant=false) 1.9910 1.8340\nTemporal Beta Diversity (Abundance, quant=true) 15.2769 16.2543\nTemporal Beta Diversity (Abundance, quant=false) 4.1324 4.5432\nTemporal Beta Diversity (Presence, quant=false) 4.1324 4.5432\nDispersal-niche continuum index 143.7430 3573.2095\nOccupied Patches Proportion 1.3019 1.4028\nVariability Metrics 7.6746 32.5536\nHypervolume Estimation 0.0085 0.0011\nHypervolume Dissimilarity 0.0120 0.0077","category":"page"},{"location":"Benchmarking/#Benchmarked-using-Small-Dataset","page":"Benchmark Results","title":"Benchmarked using Small Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.1225 0.0195\nBeta Diversity (Abundance, quant=false) 0.0883 0.0444\nBeta Diversity (Presence, quant=false) 0.0883 0.0444\nSpatial Beta Diversity (Abundance, quant=true) 1.1334 1.2160\nSpatial Beta Diversity (Abundance, quant=false) 0.7663 0.7730\nSpatial Beta Diversity (Presence, quant=false) 0.7663 0.7730\nTemporal Beta Diversity (Abundance, quant=true) 12.8811 15.4375\nTemporal Beta Diversity (Abundance, quant=false) 2.8937 3.7264\nTemporal Beta Diversity (Presence, quant=false) 2.8937 3.7264\nDispersal-niche continuum index 37.7612 912.5856\nOccupied Patches Proportion 0.3249 0.4965\nVariability Metrics 3.8483 10.5805\nHypervolume Estimation 0.0059 0.0003\nHypervolume Dissimilarity 0.0082 0.0014","category":"page"},{"location":"Benchmarking/#Remarks","page":"Benchmark Results","title":"Remarks","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"For DNCI_multigroup_result, 100 permutations are used in both the julia and R function.","category":"page"},{"location":"Benchmarking/#The-Scripts-Used-for-Benchmarking","page":"Benchmark Results","title":"The Scripts Used for Benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Julia\nR","category":"page"},{"location":"Benchmarking/#Packages-used-for-benchmarking","page":"Benchmark Results","title":"Packages used for benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"bench\nBenchmarkTools.jl","category":"page"},{"location":"DNCI/#Dispersal-Niche-Continuum-Index-(DNCI)-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The Dispersal-Niche Continuum Index (DNCI) functions in MetaCommunityMetrics quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. The function DNCI_multigroup  in this package is adapted from the R package DNCImper: Assembly process identification based on SIMPER analysis. These methods, originally developed by Clarke(1993) and later refined by Gibert & Escarguel(2019) and Vilmi et al.(2021), offer powerful tools for identifying the processes underlying species assembly in metacommunities. ","category":"page"},{"location":"DNCI/#Background","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Background","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions is built around the Per-SIMPER and DNCI analyses. PerSIMPER, based on the Similarity Percentage (SIMPER) analysis developed by Clarke (1993), assesses the contribution of individual taxa to overall dissimilarity (OAD) between groups of assemblages. PerSIMPER enhances this by comparing empirical SIMPER plots with randomized plots generated through matrix permutation, which helps identify whether niche, dispersal, or both processes are driving community assembly.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI (Dispersal-Niche Continuum Index) further extends this approach by transforming the qualitative results of PerSIMPER into a quantitative index, providing a straightforward measure of the influence of niche and dispersal processes on community structure.","category":"page"},{"location":"DNCI/#Functionality-Overview","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Functionality Overview","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions in MetaCommunityMetrics allow you to analyze the processes driving species assembly within your dataset. By comparing empirical data with randomized permutations, one can determine the extent to which niche and dispersal processes influence the structure of metacommunities. Before calculating the DNCI, groupings of sites (clusters) are required, as the DNCI relies on analyzing community composition across spatial groups. This package provides a function to perform the necessary clustering, which is not available in the equivalent R package. When the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. In contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. If the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.","category":"page"},{"location":"DNCI/#The-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"The Functions","text":"","category":"section"},{"location":"DNCI/#MetaCommunityMetrics.create_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int}, total_richness::Vector{Int}) -> Dict{Int, DataFrame}\n\nThis function creates clusters (groupings of patches/sites) for each unique time step in a dataset which can then used for calculating DNCI. Only presnece-absence data can be used. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ntime::Vector: A vector indicating the time each sample was taken.\nlatitude::Vector: A vector indicating the latitude of each sample.\nlongitude::Vector: A vector indicating the longitude of each sample.\npatch::Vector: A vector indicating the spatial location (patch) of each sample. At least 10 patches are required for clustering.\ntotal_richness::Vector: A vector indicating the total species richness at each plot at each time step.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key represents a unique time point from the input data, with the corresponding value being a DataFrame for that time step. Each DataFrame contains the following columns: Time, Latitude, Longitude, Patch, Total_Richness, and Group (indicating the assigned cluster).\n\nDetails This function performs hierarchical clustering on the geographical coordinates of sampling patches/sites at each unique time step, assuming that organism dispersal occurs within the study region. It incorporates checks and adjustments to ensure the following conditions are met: at least 2 clusters, a minimum of 5 patches/sites per cluster, and that the variation in the number of taxa/species and patches/sites per group does not exceed 40% and 30%, respectively. These conditions are critical for calculating an unbiased DNCI value, and the function will issue warnings if any are not fulfilled.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 15×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 18×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#MetaCommunityMetrics.plot_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(latitude::Vector{Float64}, longitude::Vector{Float64}, group::Union{AbstractVector, String}, output_file=\"clusters.svg\") -> String\n\nVisualizes clustering results by generating an SVG image displaying the geographic coordinates and cluster assignments of patches/sites.\n\nArguments\n\nlatitude::Vector{Float64}: A vector of latitude coordinates of the patches/sites.\nlongitude::Vector{Float64}: A vector of longitude coordinates of the patches/sites.\ngroup::Union{AbstractVector, String}: A vector or string indicating the cluster assignments for each data point.\noutput_file::String=\"clusters.svg\": The filename for the output SVG visualization. Default is \"clusters.svg\".\n\nReturns\n\nString: The path to the created SVG file.\n\nDetails\n\nThe function generates a standalone SVG file that can be viewed in any web browser or image viewer.\nEach cluster is assigned a unique color, and patches/sites are plotted based on their geographic coordinates.\nThe visualization includes a legend identifying each cluster.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2545×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2542 │    10                  117     -108.5      35.5               3\n 2543 │    12                  117     -107.5      35.5               6\n 2544 │    16                  117     -108.5      36.0               4\n 2545 │    23                  117     -108.0      36.5               5\n                                                       2536 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> plot_clusters(clustering_result[1].Latitude, clustering_result[1].Longitude, clustering_result[1].Group; output_file=\"clusters.svg\")\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"This plot shows the clustering result for time step 1 based on geographic coordinates: (Image: Cluster Plot)","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.DNCI_multigroup","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000; count::Bool=true) -> DataFrame\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021). The DNCI quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix. You can use the create_clusters function to generate the group membership.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\ncount::Bool=true: A flag indicating whether the numeber of permutations is printed. Default is false.\n\nReturns\n\nDataFrame: A DataFrame containing the DNCI value, the associate confiden interval (CI_DNCI) and variance (S_DNCI) for each pair of groups.\n\nDetails\n\nThe function calculates the DNCI for each pair of groups in the input data.\nWhen the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. \nIn contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. \nIf the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.\nPlease remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\nThis function is a translation/adaptation of a function from the R package DNCImper, licensed under GPL-3.\nOriginal package and documentation available at: https://github.com/Corentin-Gibert-Paleontology/DNCImper\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Random\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> comm= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  innerjoin(_,  total_richness_df, on = [:plot, :Sampling_date_order], makeunique = true) |>\n                  filter(row -> row[:Sampling_date_order] == 1, _) |>\n                  select(_, [:plot, :Species, :Presence]) |>\n                  unstack(_, :Species, :Presence, fill=0) |>\n                  select(_, Not(:plot)) |>\n                  Matrix(_)\n14×3 Matrix{Int64}:\n 1  0  0\n 1  0  0\n 1  0  0\n 1  0  0\n 1  1  0\n 1  1  0\n 1  0  0\n 0  0  1\n 0  1  0\n 0  1  0\n 1  0  0\n 0  1  0\n 0  0  1\n 0  0  1\n\njulia> Random.seed!(1234) \n\njulia> DNCI_result = DNCI_multigroup(comm, clustering_result[1].Group, 1000; count = false)\n1×5 DataFrame\n Row │ group1  group2  DNCI      CI_DNCI  S_DNCI  \n     │ Int64   Int64   Float64   Float64  Float64 \n─────┼────────────────────────────────────────────\n   1 │      1       2  0.045603  6.52576  3.26288\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#References","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"References","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"Clarke, K. R. Non-parametric multivariate analyses of changes in community structure. Australian Journal of Ecology 18, 117-143 (1993). https://doi.org:https://doi.org/10.1111/j.1442-9993.1993.tb00438.x\nGibert, C. & Escarguel, G. PER-SIMPER—A new tool for inferring community assembly processes from taxon occurrences. Global Ecology and Biogeography 28, 374-385 (2019). https://doi.org:https://doi.org/10.1111/geb.12859\nVilmi, A. et al. Dispersal–niche continuum index: a new quantitative metric for assessing the relative importance of dispersal versus niche processes in community assembly. Ecography 44, 370-379 (2021). https://doi.org:https://doi.org/10.1111/ecog.05356","category":"page"},{"location":"Hypervolume/#Hypervolume-Functions","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Hypervolume is a method originally proposed by Hutchinson (1957). It provide methods to calculate the volume of a niche for a given specice and thus the ncihe overlap between two species. It helps to infer how niche breath of species has contribute to the co-occurance of different species in the same location at the same time. The hypervolume functions provide by this package are adapted from the R package MVNH (https://github.com/lvmuyang/MVNH).","category":"page"},{"location":"Hypervolume/#An-Overview","page":"Hypervolume Functions","title":"An Overview","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The MVNH framework provides parametric measures for analyzing ecological niches using the multivariate normal distribution model. This framework offers powerful tools for quantifying and comparing the size and dissimilarity of species' niches, with each measure being partitionable into biologically meaningful components.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The framework models a species' niche as a multivariate normal distribution in environmental space, where:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Each environmental variable represents one dimension of the niche.\nThe mean vector represents the niche optimum.\nThe covariance matrix represents the niche breadth and shape.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"There are four hypervolume functions in this package:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"MVNH_det calculates the total hypervolume of a species' niche based on the determinant of the covariance matrix (generalized variance). This measure can be partitioned into:\nMVNH_dissimilarity calculates the Bhattacharyya distance between two species' niches, providing a comprehensive measure of niche differentiation. \naverage_MVNH_det calculates the mean hypervolume across multiple species in a community, providing an overall measure of niche size at the community level.\naverage_MVNH_dissimilarity calculates the mean Bhattacharyya distance between all unique pairs of species in a community, providing a measure of overall niche differentiation.","category":"page"},{"location":"Hypervolume/#Practical-Considerations","page":"Hypervolume Functions","title":"Practical Considerations","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Statistical assumptions: This framework relies on multivariate normal distribution of environmental data.\nWhen encountering skewed variables, apply appropriate transformations to normalize distributions.\nBe aware that as you increase the number of variables, you face greater challenges with:\nVariable interdependence (collinearity) which can drive determinant values toward zero\nPotential violations of the multivariate normality assumption\nAddress variable interdependence through either:\nThoughtful pre-selection of ecologically meaningful variables with direct influence on species distributions\nApplication of dimension reduction methods such as PCA (principal component analysis)\nImportant note: PCA creates orthogonal axes, which forces the correlation component to 1.0, eliminating correlation structure information.\nFor datasets containing multiple distinct groups of related environmental variables (such as climate factors, soil properties, or topographic features), consider using generalized canonical variables to identify the most representative variables within each natural category while preserving the ecological relationships between different variable groups.\nMeasurement standardization: Before analysis, standardize all environmental variables to comparable scales to prevent variables with larger numerical ranges from disproportionately influencing results.","category":"page"},{"location":"Hypervolume/#The-Functions","page":"Hypervolume Functions","title":"The Functions","text":"","category":"section"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_det","text":"MVNH_det(data::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate the niche hypervolume of a species based on environmental variables.\n\nArguments\n\ndata::DataFrame: DataFrame where each row represents an observation of a species (presence only, need to filter out absences) and columns represent environmental variables.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A DataFrame containing:\nCorrelation: The correlation component (calculated as det(COV)/prod(variances))\nOne column for each environmental variable showing its variance\ntotal: The total hypervolume (calculated as the determinant of the covariance matrix)\n\nDetails\n\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\nThe function computes the covariance matrix of the input data, extracts variances, and calculates the determinant\nThis function is a Julia implementation of the MVNH_det function from the R package MVNH (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics, UnicodePlots\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n143×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> result = MVNH_det(data; var_names=[\"Temperature\", \"Precipitation\"])\n1×4 DataFrame\n Row │ total    correlation  Temperature  Precipitation \n     │ Float64  Float64      Float64      Float64       \n─────┼──────────────────────────────────────────────────\n   1 │ 1.15268     0.999732     0.962495        1.19792\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_dissimilarity","text":"MVNH_dissimilarity(data_1::DataFrame, data_2::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate niche dissimilarity between two species based on their environmental variables, using the Bhattacharyya distance and its components.\n\nArguments\n\ndata_1::DataFrame: DataFrame for the first species, where each row represents an observation (presence only, need to filter out absences) and columns represent environmental variables.\ndata_2::DataFrame: DataFrame for the second species, with the same structure as data_1.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A dataframe containing three metrics and their components:\n\"Bhattacharyya_distance\": The total Bhattacharyya distance and its components\n\"Mahalanobis_distance\": The Mahalanobis component of the Bhattacharyya distance\n\"Determinant_ratio\": The determinant ratio component of the Bhattacharyya distance\nEach metric contains:\ntotal: The total value of the respective distance measure\ncorrelation: The correlation component of the distance measure\nOne value for each environmental variable showing its contribution to the distance\n\nDetails\n\nThe Bhattacharyya distance is calculated as the sum of two components:\nMahalanobis component: (1/8) × (μ₁-μ₂)ᵀ × (S₁+S₂)/2⁻¹ × (μ₁-μ₂)\nDeterminant ratio component: (1/2) × log(det((S₁+S₂)/2) / sqrt(det(S₁) × det(S₂)))\nEach component is further decomposed into individual variable contributions and correlation effects\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\nThis function is a Julia implementation inspired by the MVNH R package (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n\njulia> data_1 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n\n143×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> data_2 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"SH\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n58×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │              -0.229864                  1.84371\n   2 │               0.460218                 -0.624328\n   3 │              -1.03283                  -1.16451\n   4 │               0.675006                 -0.120586\n   5 │               0.40729                   0.20034\n  ⋮  │           ⋮                        ⋮\n  54 │              -0.870299                 -0.235392\n  55 │               0.504555                 -1.50887\n  56 │               2.03065                  -0.740789\n  57 │              -0.174396                  0.448461\n  58 │               0.547169                  1.03257\n                                         48 rows omitted\n                   \njulia> result = MVNH_dissimilarity(data_1, data_2; var_names=[\"Temperature\", \"Precipitation\"])\n3×5 DataFrame\n Row │ metric                  total       correlation  Temperature  Precipitation \n     │ String                  Float64     Float64      Float64      Float64       \n─────┼─────────────────────────────────────────────────────────────────────────────\n   1 │ Bhattacharyya_distance  0.00980771  0.00015205    0.00388058     0.00577508\n   2 │ Mahalanobis_distance    0.00664862  5.06232e-6    0.00234902     0.00429454\n   3 │ Determinant_ratio       0.00315908  0.000146988   0.00153156     0.00148054\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_det","text":"average_MVNH_det(data::DataFrame, presence_absence::Vector{Int}, species::Vector{String}; \n                 var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche hypervolume across multiple species in a community dataset.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Vector{String}: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average hypervolume across all species with presence data.\n\nDetails\n\nFor each unique species, the function:\nFilters observations where the species is present (presence_absence > 0)\nCalculates the niche hypervolume using the MVNH_det function\nExtracts the total hypervolume value\nThe function then computes the mean of all individual species hypervolumes\nSpecies with no presence data are skipped in the calculation\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:normalized_temperature, :normalized_precipitation])\n           \n53352×2 DataFrame\n   Row │ normalized_temperature  normalized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_det(data, df.Presence, String.(df.Species); var_names=[\"Temperature\", \"Precipitation\"])\n1.2103765096417536\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_dissimilarity","text":"average_MVNH_dissimilarity(data::DataFrame, presence_absence::Vector{Int}, species::Union{Integer, String, PooledArrays.PooledVector}; \n                          var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche dissimilarity between all unique pairs of species in a community dataset using Bhattacharyya distance.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Vector{String}: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average Bhattacharyya distance across all unique species pairs.\n\nDetails\n\nFor each unique pair of species, the function:\nFilters observations where each species is present (presence_absence > 0)\nCalculates the niche dissimilarity using the MVNH_dissimilarity function\nExtracts the total Bhattacharyya distance value\nThe function then computes the mean of all pairwise Bhattacharyya distances\nSpecies pairs where either species has no presence data are skipped\nEach species pair is processed only once (i.e., sp1-sp2 is calculated, but sp2-sp1 is skipped)\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:normalized_temperature, :normalized_precipitation])    \n53352×2 DataFrame\n   Row │ normalized_temperature  normalized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_dissimilarity(data, df.Presence, String.(df.Species); var_names=[\"Temperature\", \"Precipitation\"])     \n0.03059942936454443\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#References","page":"Hypervolume Functions","title":"References","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Lu, Muyang, Kevin Winner, and Walter Jetz. A unifying framework for quantifying and comparing n‐dimensional hypervolumes. Methods in Ecology and Evolution 12.10, 1953-1968 (2021). https://doi.org/10.1111/2041-210X.13665","category":"page"}]
}
