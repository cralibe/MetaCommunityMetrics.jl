var documenterSearchIndex = {"docs":
[{"location":"NicheOverlapIndex/#Niche-Overlap-Index-Function","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"Niche overlap refers to the extent to which different species use the same resources or occupy similar ecological niches. High niche overlap might indicate intense competition, whereas low overlap suggests niche differentiation, allowing species to coexist by minimizing direct competition.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"To capture the changes in density-independent abiotic response, also known as niche breadth, this implementation uses Pianka's Niche Overlap Index, as suggested by Pianka (1973). The summary statistics of this index include the mean, maximum, and minimum values across all species pairs, providing a comprehensive understanding of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/#Functionality-Overview","page":"Niche Overlap Index Function","title":"Functionality Overview","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"The Niche Overlap Index functions in MetaCommunityMetrics provide a robust framework for calculating niche overlap based on species abundance or presence-absence data. These functions allow you to evaluate how species share ecological space within a metacommunity, offering valuable insights into community dynamics and species interactions.","category":"page"},{"location":"NicheOverlapIndex/#The-Function","page":"Niche Overlap Index Function","title":"The Function","text":"","category":"section"},{"location":"NicheOverlapIndex/#MetaCommunityMetrics.niche_overlap","page":"Niche Overlap Index Function","title":"MetaCommunityMetrics.niche_overlap","text":"niche_overlap(abundance::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}, time::AbstractVector) -> DataFrame\n\nCalculates the overall mean, maximum, and minimum values of the niche overlap index from all species pairs in the provided data.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\nspecies::Union{AbstractVector, String}: Vector or string representing species names or IDs.\npatch::Union{AbstractVector, String}: Vector or string representing patch names or IDs.\ntime::AbstractVector: Vector representing the time points.\n\nDescription\n\nThe niche overlap index is calculated based on the method suggested by Pianka (1973), with the assumption that the proportional use of a species at a specific site and time equals its relative abundance at that site and time. To determine relative abundance, the abundance of each species in a particular patch is divided by the total abundance of that species across all patches and times.\n\nReturns\n\nDataFrame: A DataFrame containing the overall mean, maximum, and minimum values of the niche overlap index from all species pairs.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> result = niche_overlap(df.Abundance, df.Species, df.plot, df.Sampling_date_order)\n1×3 DataFrame\n Row │ mean_niche_overlap_index  min_niche_overlap_index  max_niche_overlap_index \n     │ Float64                   Float64                  Float64                 \n─────┼────────────────────────────────────────────────────────────────────────────\n   1 │                 0.827739                 0.591836                      1.0\n\n\n\n\n\n","category":"function"},{"location":"NicheOverlapIndex/#References","page":"Niche Overlap Index Function","title":"References","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"MacArthur, R. & Levins, R. The limiting similarity, convergence, and divergence of coexisting species. The American Naturalist 101, 377-385 (1967). \nPianka, E. R. (1974). \"Niche overlap and diffuse competition.\" Proceedings of the National Academy of Sciences, 71(5), 2141-2145.\nPianka, E. R. (1973). \"The Structure of Lizard Communities.\" Annual Review of Ecology and Systematics, 4(1), 53-74.","category":"page"},{"location":"Validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"We validate all the calcuations in MetaCommunityMetrics that have equvilant functions in R to make sure the functions in MetaCommunityMetrics are correct and accurate as the equvilant functions in R. All validation results are presented to 4 decimal places (±0.0001) here. Floating-point differences between implementations smaller than 0.0001 were considered negligible for both statistical and ecological applications of these metrics.","category":"page"},{"location":"Validation/#Validation-Result","page":"Validation","title":"Validation Result","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Below is a comparison of the results between MetaCommunityMetrics and functions/equivalent implementation in R.","category":"page"},{"location":"Validation/#Beta-Diversity","page":"Validation","title":"Beta Diversity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here. All values *","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"TestCase BDtotal Repl RichDif\nBeta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nBeta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nBeta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Dispersal-niche-continuum-index","page":"Validation","title":"Dispersal-niche continuum index","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*A plot showing the distribution of the DNCI values of diffent group pairs from different programming language, each pair are runned for 100 times. (Image: Julia vs. R)","category":"page"},{"location":"Validation/#Occupied-Patches-Proportion","page":"Validation","title":"Occupied Patches Proportion","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"minproppatches meanproppatches maxproppatches\n0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Variability-Metrics","page":"Validation","title":"Variability Metrics","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"CVSL CVCL CVSR CVCR\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Hypervolume","page":"Validation","title":"Hypervolume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/#Volume","page":"Validation","title":"Volume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"total correlation Temperature Precipitation\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Volume-dissimilarity","page":"Validation","title":"Volume dissimilarity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Metric total correlation Temperature Precipitation\nBhattacharyya_distance 0.0000 0.0000 0.0000 0.0000\nMahalanobis_distance 0.0000 0.0000 0.0000 0.0000\nDeterminant_ratio 0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Running-Validation","page":"Validation","title":"Running Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"The script to run this validation result can be found here.","category":"page"},{"location":"OccupiedPatchesProportion/#Occupied-Patches-Proportion-Function","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion function in MetaCommunityMetrics provides a simple yet powerful metric for understanding the distribution and prevalence of species across different habitat patches within a metacommunity. By calculating the averaged, minmum and maximum proportion of patches occupied across species, this function helps ecologists assess the spatial extent of species distributions and identify potential patterns of rarity or commonness across the landscape.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"This function draws on the concepts discussed by Ehrlén & Eriksson (2000) in their study on dispersal limitation and patchy occupancy in forest herbs. According to their findings, low occupancy may indicate dispersal limitation or strong competition, while high occupancy could suggest mass effects due to high dispersal rates or the ability to thrive in various conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#An-Overview","page":"Occupied Patches Proportion Function","title":"An Overview","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion metric quantifies the averaged proportion of habitat patches in which a species is present. This information is crucial for understanding species distributions, particularly in fragmented landscapes or patchy environments where species may not occupy all available habitat. This metric can be used to identify widespread species, which occupy a large number of patches, as well as rare species, which are restricted to only a few patches.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"After calculating the proportion of patches occupied for each species, the mean, minimum, and maximum proportion of patches occupied can be derived. These values are valuable indicators of ecological processes:","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Low proportion of patches occupied: May indicate dispersal limitation or strong competition among species. Such patterns could suggest that certain species struggle to colonize or persist in many patches.\nHigh proportion of patches occupied: May point to mass effects, where species are abundant in many patches, possibly due to high dispersal rates or the ability to thrive across a range of conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#The-Function","page":"Occupied Patches Proportion Function","title":"The Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/#MetaCommunityMetrics.prop_patches","page":"Occupied Patches Proportion Function","title":"MetaCommunityMetrics.prop_patches","text":"prop_patches(presence::AbstractVector, species::Union{AbstractVector, String}, patch::Union{AbstractVector, String}) -> DataFrame\n\nCalculate the proportion of patches occupied by each species and summarize the results.\n\nThis function takes three vectors: presence, species, and patch, and performs the following steps:\n\nArguments\n\npresence::AbstractVector: A vector indicating the presence (1) or absence (0) of a species in a patch.\nspecies::Union{AbstractVector, String}: A vector of species names.\npatch::Union{AbstractVector, String}: A vector of patch identifiers.\n\nReturns\n\nDataFrame: A DataFrame containing the mean, minimum, and maximum proportion of patches               occupied across all species.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n                                                                                          \njulia> prop_patches(df.Presence, df.Species, df.plot)\n1×3 DataFrame\n Row │ mean_prop_patches  min_prop_patches  max_prop_patches \n     │ Float64            Float64           Float64          \n─────┼───────────────────────────────────────────────────────\n   1 │          0.734649         0.0833333               1.0\n\n\n\n\n\n","category":"function"},{"location":"OccupiedPatchesProportion/#References","page":"Occupied Patches Proportion Function","title":"References","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Ehrlén, J., & Eriksson, O. (2000). Dispersal Limitation and Patchy Occupancy in Forest Herbs. Ecology, 81(6), 1667-1674. https://doi.org:https://doi.org/10.1890/0012-9658(2000)081[1667:DLAPOI]2.0.CO;2","category":"page"},{"location":"#MetaCommunityMetrics.jl","page":"Home","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of tools and utilities for analyzing meta-communities in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#An-Overview","page":"Home","title":"An Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a comprehensive toolkit designed to characterize the spatiotemporal structure and dynamics of a metacommunity—a network of communities linked by the dispersal of multiple, interacting species, each with unique niche breadths. It includes functions to calculate a range of specific metrics, which have been previously implemented in R and proven valuable for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, they come with high computational costs, especially for large species community datasets. To address this issue, MetaCommunityMetrics.jl was developed in Julia, a programming language known for its efficiency in handling computationally intensive tasks. This implementation significantly improves the efficiency of calculating these metrics, making it a powerful tool for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beta diversity decompositions in space/time: total diversity, species replacement (turnover), and richness differences for both presence-absence and abundance data\nDispersal-niche continuum index to evaluate the degree to which communities are influenced by dispersal processes and niche breadth\nNiche overlap indices to determine the extent of niche sharing among species within the metacommunity\nThe proportion of habitat patches occupied by each species\nThe variability of community composition across different spatial and temporal scales\nNiche hypervolume measurements (individual species, average, and between-species dissimilarities)","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"MetaCommunityMetrics\")\n\nusing MetaCommunityMetrics","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta Diversity\nDNCI\nNiche Overlap Index\nOccupied Patches Proportion\nVariability Metrics\nHypervolume","category":"page"},{"location":"#Comparison-between-Julia-and-R-implementations","page":"Home","title":"Comparison between Julia and R implementations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Validation\nBenchmarking","category":"page"},{"location":"#Accessing-the-Sample-Data-for-exploring-the-functions","page":"Home","title":"Accessing the Sample Data for exploring the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes rodent data from the Portal Project, a long-term study of a Chihuahuan desert ecosystem (available at https://github.com/weecology/portalr), as sample data for testing and benchmarking functions between Julia and R. The original rodent abundance data were collected monthly across 24 plots, recording a total of 21 species. For the purposes of this package, the data are filtered for the period from 2010 to 2023, transformed into long format, and species that were not recorded during this period are removed. Additionally, plots with no observations during the whole sampling period are excluded. A new column, Sampling_date_order, was created to sequentially number the sampling dates, starting at 1 and continuing through 117, to facilitate analysis. The locations of the plots (Latitude and Longitude) were simulated for testing the DNCI functions. The temperature and precipatation data were simulated for testing the hypervolume functions. The scripts to download and wrangle the original data can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Downloading the rodent data\nData Wrangling","category":"page"},{"location":"","page":"Home","title":"Home","text":"To assess the sample data, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MetaCommunityMetrics\n\nload_sample_data()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using MetaCommunityMetrics\n\njulia> load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted","category":"page"},{"location":"#Acknowledgment","page":"Home","title":"Acknowledgment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Acknowledgment","category":"page"},{"location":"BetaDiversity/#Beta-Diversity-Functions","page":"Beta Diverisity Functions","title":"Beta Diversity Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Beta diversity is a fundamental concept in ecology that quantifies the variation in species composition between different plots, or over time. In the context of metacommunity analysis, beta diversity functions help to assess how community composition changes spatially across different locations or temporally within a metacommunity.","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"The beta_diversity functions in MetaCommunityMetrics are adapted from the beta.div.comp function in the R package adespatial. These methods, originally developed by Pierre Legendre (2014), are implemented in Julia to provide a more efficient means of computation for large-scale datasets. The functions use indices from the Podani family, Jaccard-based indices, and Ruzicka-based indices to calculate total beta diversity and its components: replacement and richness difference.","category":"page"},{"location":"BetaDiversity/#Choosing-the-Right-Function","page":"Beta Diverisity Functions","title":"Choosing the Right Function","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Use beta_diversity for a general, comprehensive measure of beta diversity across your dataset. This function provides an overall assessment of how species composition varies between sites or over time, capturing both replacement (the turnover of species) and richness difference(the difference in species richness). \nUse spatial_beta_div to comparing diversity between different spatial locations of a metacommunity. \nUse temporal_beta_div to track how diversity changes over time of a metacommunity. ","category":"page"},{"location":"BetaDiversity/#The-Functions","page":"Beta Diverisity Functions","title":"The Functions","text":"","category":"section"},{"location":"BetaDiversity/#MetaCommunityMetrics.beta_diversity","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative data.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a sample and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects how many species are different in one site compared to another, ignoring the species that are mere additions or subtractions.\nRichDif: Richness difference component of diversity, which captures the disparity in biodiversity in terms of the count of species present, without taking into account the specific identities or distributions of those species.\n\nDetails\n\nEmpty patches have to be removed before calculation.\nSpecies that were not recorded at the given time step have to be removed before calculation.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThis function is a translation/adaptation of the beta.dov.comp function from the R package adespatial,licensed under GPL-3.\nOriginal package and documentation available at: https://cran.r-project.org/web/packages/adespatial/index.html\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String   Int64      Int64     Float64   Float64    Float64?                Float64?                 \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> matrix_with_abundance = @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :normalized_temperature, :normalized_precipitation, :Presence)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           unstack(_, :Species, :Abundance, fill=0) |>  \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix\n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:] \n15×5 Matrix{Union{Missing, Int64}}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 2  0  0  0  0\n 1  0  0  1  0\n 4  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  2  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> matrix_with_presence =  @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :normalized_temperature, :normalized_precipitation, :Abundance)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |>\n           unstack(_, :Species, :Presence, fill=0) |> \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix      \n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  1  0\n 1  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  1  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> result_using_abanduce_data_1 = beta_diversity(matrix_with_abundance; quant=true)\n1×3 DataFrame\n Row │ BDtotal   Repl     RichDif  \n     │ Float64   Float64  Float64  \n─────┼─────────────────────────────\n   1 │ 0.390317   0.2678  0.122517\n\njulia> result_using_abanduce_data_2 = beta_diversity(matrix_with_abundance; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\njulia> result_using_binary_data = beta_diversity(matrix_with_presence; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.spatial_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.spatial_beta_div","text":"spatial_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}; quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in space based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in space. Columns are spatial_BDtotal, spatial_Repl, and spatial_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components after aggregating .\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in space is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> result_using_abanduce_data_1 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.264822      0.121882         0.142939\n        \njulia> result_using_abanduce_data_2 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\njulia> result_using_binary_data = spatial_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.temporal_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.temporal_beta_div","text":"temporal_beta_div(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String};quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in time based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::Vector: A vector containing abundance data for each species across different samples.\ntime::Vector: A vector indicating the time each sample was taken.\npatch::Vector: A vector indicating the spatial location (patch) of each sample.\nspecies::Vector: A vector indicating the species associated with each abundance entry.\nquant::Bool: A boolean flag that specifies whether the data is quantitative. By default, it is set to false, which means the data will be treated as binary. In this case, any quantitative data will be converted to binary, and beta diversity is calculated using the Podani family’s Jaccard-based indices. If true, the data is treated as quantitative, and beta diversity is calculated using the Podani family’s Ruzicka-based indices. For binary data, quant must remain set to false.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in time. Columns are temporal_BDtotal, temporal_Repl, and temporal_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each patch.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in time is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> result_using_abanduce_data_1 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.311222      0.0995483          0.211674\n        \njulia> result_using_abanduce_data_2 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\njulia> result_using_binary_data = temporal_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#References","page":"Beta Diverisity Functions","title":"References","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Guzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683\nLegendre, P. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography 23, 1324-1334 (2014). https://doi.org:https://doi.org/10.1111/geb.12207","category":"page"},{"location":"VariabilityMetrics/#Variability-Metrics-Functions","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics functions in MetaCommunityMetrics are designed to capture changes in dispersal and density-dependent biotic interactions by investigating temporal variability and synchrony across spatial scales and organizational levels within a metacommunity. These functions are based on the work of Wang et al. (2019), which provides a framework for quantifying variability at different scales and contexts within a community.","category":"page"},{"location":"VariabilityMetrics/#An-Overview","page":"Variability Metrics Functions","title":"An Overview","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In MetaCommunityMetrics, the CV_meta function is directly adapted from the R function var.partition in Wang et al. (2019).","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The function provides four metrics that are designed to quantify variability at different scales and contexts within a metacommunity:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Local-scale average species variability (CV_s_l)\nRegional-scale average species variability (CV_s_r)\nLocal-scale average community variability (CV_c_l)\nRegional-scale community variability (CV_c_r)","category":"page"},{"location":"VariabilityMetrics/#The-Function","page":"Variability Metrics Functions","title":"The Function","text":"","category":"section"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta","text":"CV_meta(abundance::AbstractVector, time::AbstractVector, patch::Union{AbstractVector, String}, species::Union{AbstractVector, String}) -> DataFrame\n\nCalculates coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity.\n\nArguments\n\nabundance::AbstractVector: A vector representing the abundance of species.\ntime::AbstractVector: A vector representing the time points at which the abundance measurements were taken.\npatch::Union{AbstractVector, String}: A vector or single value representing the patch or plot identifier.\nspecies::Union{AbstractVector, String}: A vector or single value representing the species identifier.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = @pipe load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> CV_summary_df = CV_meta(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.48859  0.944937  0.718266  0.580183\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#References","page":"Variability Metrics Functions","title":"References","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290","category":"page"},{"location":"Acknowledgment/#Acknowledgment","page":"Acknowledgment","title":"Acknowledgment","text":"","category":"section"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package includes translations and adaptations of functions from the R packages adespatial (licensed under GPL-3), vegan (licensed under GPL-2 or later), DNCImper (licensed under GPL-3), and MVNH (licensed under GPL-3). The original packages and their documentation are available at:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"adespatial: https://cran.r-project.org/web/packages/adespatial/index.html\nvegan: https://cran.r-project.org/web/packages/vegan/index.html\nDNCImper: https://github.com/Corentin-Gibert-Paleontology/DNCImper\nMVNH : https://github.com/lvmuyang/MVNH","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package also includes translations and adaptations of functions that are provided by the scripts of these papers:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290\nGuzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Please refer to these sources for full details on the original implementations and licenses.","category":"page"},{"location":"Benchmarking/#Benchmarking-Results","page":"Benchmarking Julia vs R","title":"Benchmarking Results","text":"","category":"section"},{"location":"Benchmarking/#Computational-Resources","page":"Benchmarking Julia vs R","title":"Computational Resources","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"All benchmarks were performed on the same machine to ensure consistent comparisons.","category":"page"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"CPU: Apple M4\nNumber of Cores: 10\nMemory: 16GB RAM\nOperating System: macOS Sequoia 15.5\nJulia Version: 1.10.9\nR Version: 4.4.2","category":"page"},{"location":"Benchmarking/#Bechmarking-Methods","page":"Benchmarking Julia vs R","title":"Bechmarking Methods","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"To assess the efficiency of MetaCommunityMetricscompared to equivalent R implementations, we benchmark our functions against equivalent implementations in R, focusing on comparing the time and memory usage. The following tables summarized the benchmarking results. We tested using datasets of three sizes: small (5325 observations), medium (26676 observations), and large (53352 observations). The larger dataset is the sample data of MetaCommunityMetrics, which can be accessed by using load_sample_data(). The small and medium dataset can be accessed here. Each function was benchmarked using 100 samples in both BenchmarkTools.jl in Julia and bench::mark() in R to ensure robust statistical sampling. For memory usage comparisons, we report Julia's memory estimate from BenchmarkTools.jl. According to the BenchmarkTools.j documentation, this measurement returns the number of bytes allocated when executing a given expression, corresponding to the trial with the minimum elapsed time measured during benchmarking. For R, we report the mem_alloc metric from bench::mark(), which specifically tracks R heap allocations, with the documentation noting that it excludes 'memory allocated outside the R heap, e.g., by malloc() or new directly. Both metrics measure heap memory allocations within their respective language runtimes. Due to differences in language implementation and measurement methodology, direct numerical comparisons between languages should be interpreted with caution. ","category":"page"},{"location":"Benchmarking/#Benchmarking-using-the-large-dataset","page":"Benchmarking Julia vs R","title":"Benchmarking using the large dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"All times are in millisecond (ms), and memory is in mebibytes (MiB). All values are rounded up to 4 decimal places.","category":"page"},{"location":"Benchmarking/#Julia","page":"Benchmarking Julia vs R","title":"Julia","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 0.1047 0.1359 0.2862 2.3685 0.3502 0.4346\nBeta Diversity (Abundance, quant=false) 0.0108 0.0170 0.1825 8.1686 1.0067 0.1347\nBeta Diversity (Presence, quant=false) 0.0102 0.0115 0.1738 10.0957 1.0664 0.1347\nSpatial Beta Diversity (Abundance, quant=true) 1.0407 1.1159 1.2525 4.1448 0.5467 3.9185\nSpatial Beta Diversity (Abundance, quant=false) 0.9028 1.0091 1.0973 3.7046 0.4355 3.5173\nSpatial Beta Diversity (Presence, quant=false) 0.8751 1.0448 1.1481 3.7535 0.4430 3.5173\nTemporal Beta Diversity (Abundance, quant=true) 4.0484 4.4040 5.1821 15.0618 1.6165 16.8838\nTemporal Beta Diversity (Abundance, quant=false) 1.6742 1.8266 2.1790 9.2889 1.1900 5.6586\nTemporal Beta Diversity (Presence, quant=false) 1.6390 1.8623 2.0460 4.4411 0.5831 5.6586\nDispersal-niche continuum index 143.1201 147.7740 149.8734 206.0497 7.7826 408.4675\nOccupied Patches Proportion 0.7545 0.9106 1.0019 4.1220 0.4708 2.5230\nVariability Metrics 11.9627 12.5781 12.8409 15.1580 0.7824 12.4573\nHypervolume Estimation 0.0033 0.0038 0.0043 0.0537 0.0050 0.0122\nHypervolume Dissimilarity 0.0057 0.0064 0.0075 0.0872 0.0082 0.0168","category":"page"},{"location":"Benchmarking/#R","page":"Benchmarking Julia vs R","title":"R","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 2.7006 4.4541 10.4123 541.1395 53.6438 0.0566\nBeta Diversity (Abundance, quant=false) 0.2130 0.2601 0.4028 2.3464 0.3122 0.1252\nBeta Diversity (Presence, quant=false) 0.2256 0.2670 0.3392 1.4041 0.1947 0.1252\nSpatial Beta Diversity (Abundance, quant=true) 15.1884 21.9025 22.7474 82.2930 7.8687 3.1113\nSpatial Beta Diversity (Abundance, quant=false) 10.8790 16.5718 20.5865 285.4170 27.7484 2.6683\nSpatial Beta Diversity (Presence, quant=false) 10.3769 14.6347 15.7660 54.5412 6.1221 2.6683\nTemporal Beta Diversity (Abundance, quant=true) 95.3134 114.8494 127.8791 513.7155 60.3508 16.8833\nTemporal Beta Diversity (Abundance, quant=false) 14.2315 18.4020 22.2465 332.8670 31.5405 5.1722\nTemporal Beta Diversity (Presence, quant=false) 14.2623 18.3448 19.2711 43.8397 4.0817 5.1722\nDispersal-niche continuum index 16150.8938 23881.0763 23694.5085 33782.7078 2608.4650 8347.5709\nOccupied Patches Proportion 11.4863 16.1346 16.6754 26.2392 3.2114 1.8827\nVariability Metrics 223.6846 314.4044 413.6490 1656.9433 289.0475 60.0667\nHypervolume Estimation 0.0558 0.1042 0.1054 0.2251 0.0256 0.0022\nHypervolume Dissimilarity 0.1825 0.2540 0.3457 0.8766 0.1756 0.0145","category":"page"},{"location":"Benchmarking/#Speedup","page":"Benchmarking Julia vs R","title":"Speedup","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Timemedianjulia Timemedianr Speedup\nBeta Diversity (Abundance, quant=true) 0.1359 4.4541 32.7757\nBeta Diversity (Abundance, quant=false) 0.0170 0.2601 15.3026\nBeta Diversity (Presence, quant=false) 0.0115 0.2670 23.1789\nSpatial Beta Diversity (Abundance, quant=true) 1.1159 21.9025 19.6281\nSpatial Beta Diversity (Abundance, quant=false) 1.0091 16.5718 16.4223\nSpatial Beta Diversity (Presence, quant=false) 1.0448 14.6347 14.0068\nTemporal Beta Diversity (Abundance, quant=true) 4.4040 114.8494 26.0784\nTemporal Beta Diversity (Abundance, quant=false) 1.8266 18.4020 10.0744\nTemporal Beta Diversity (Presence, quant=false) 1.8623 18.3448 9.8507\nDispersal-niche continuum index 147.7740 23881.0763 161.6054\nOccupied Patches Proportion 0.9106 16.1346 17.7182\nVariability Metrics 12.5781 314.4044 24.9962\nHypervolume Estimation 0.0038 0.1042 27.7980\nHypervolume Dissimilarity 0.0064 0.2540 39.7179","category":"page"},{"location":"Benchmarking/#Benchmarking-using-the-medium-dataset","page":"Benchmarking Julia vs R","title":"Benchmarking using the medium dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"All times are in millisecond (ms), and memory is in mebibytes (MiB). All values are rounded up to 4 decimal places.","category":"page"},{"location":"Benchmarking/#Julia-2","page":"Benchmarking Julia vs R","title":"Julia","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 0.0647 0.0853 0.1210 0.5125 0.0796 0.2491\nBeta Diversity (Abundance, quant=false) 0.0078 0.0160 0.0154 0.0355 0.0044 0.1086\nBeta Diversity (Presence, quant=false) 0.0067 0.0083 0.0090 0.0310 0.0030 0.1086\nSpatial Beta Diversity (Abundance, quant=true) 0.7606 0.9022 1.0497 4.5912 0.5313 2.3897\nSpatial Beta Diversity (Abundance, quant=false) 0.6500 0.7594 0.8366 2.8606 0.3347 1.9910\nSpatial Beta Diversity (Presence, quant=false) 0.6063 0.7095 0.8539 7.7896 0.8100 1.9910\nTemporal Beta Diversity (Abundance, quant=true) 3.7435 4.0110 4.4374 9.5260 0.9203 15.2769\nTemporal Beta Diversity (Abundance, quant=false) 1.1183 1.3314 1.5423 6.5418 0.7577 4.1324\nTemporal Beta Diversity (Presence, quant=false) 1.0437 1.2106 1.3106 4.0138 0.4640 4.1324\nDispersal-niche continuum index 51.6221 53.4701 53.6385 57.3854 0.9387 143.7355\nOccupied Patches Proportion 0.5801 0.6862 0.7330 1.7060 0.1706 1.3019\nVariability Metrics 7.2410 7.4703 7.7076 10.3640 0.6414 7.6746\nHypervolume Estimation 0.0030 0.0034 0.0039 0.0504 0.0047 0.0085\nHypervolume Dissimilarity 0.0048 0.0054 0.0062 0.0773 0.0072 0.0120","category":"page"},{"location":"Benchmarking/#R-2","page":"Benchmarking Julia vs R","title":"R","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 1.8467 2.7219 3.3254 11.5697 1.8266 0.0357\nBeta Diversity (Abundance, quant=false) 0.2459 0.3299 0.4395 2.0706 0.3433 0.0798\nBeta Diversity (Presence, quant=false) 0.2383 0.3195 0.4647 3.1369 0.4921 0.0798\nSpatial Beta Diversity (Abundance, quant=true) 14.7974 20.6098 29.2914 385.6328 50.7938 2.2707\nSpatial Beta Diversity (Abundance, quant=false) 9.6693 13.5177 15.0492 49.3984 5.8203 1.8277\nSpatial Beta Diversity (Presence, quant=false) 10.2190 14.7190 15.0275 28.9880 3.1351 1.8277\nTemporal Beta Diversity (Abundance, quant=true) 81.9918 114.5111 149.0064 1049.1010 169.9126 16.2479\nTemporal Beta Diversity (Abundance, quant=false) 12.0927 17.6840 25.9879 672.2291 65.5459 4.5368\nTemporal Beta Diversity (Presence, quant=false) 14.0173 18.3145 18.5485 24.8850 2.0702 4.5368\nDispersal-niche continuum index 7890.5657 9162.7688 9536.9359 22655.8338 1805.3635 3573.2095\nOccupied Patches Proportion 10.2833 14.9776 17.9419 89.8005 10.7927 1.3965\nVariability Metrics 97.7768 141.9484 172.3243 744.6694 132.1003 32.5536\nHypervolume Estimation 0.0292 0.0402 0.0568 0.4308 0.0518 0.0011\nHypervolume Dissimilarity 0.1382 0.2190 0.4250 3.6017 0.5595 0.0077","category":"page"},{"location":"Benchmarking/#Speedup-2","page":"Benchmarking Julia vs R","title":"Speedup","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Timemedianjulia Timemedianr Speedup\nBeta Diversity (Abundance, quant=true) 0.0853 2.7219 31.8970\nBeta Diversity (Abundance, quant=false) 0.0160 0.3299 20.5928\nBeta Diversity (Presence, quant=false) 0.0083 0.3195 38.3334\nSpatial Beta Diversity (Abundance, quant=true) 0.9022 20.6098 22.8437\nSpatial Beta Diversity (Abundance, quant=false) 0.7594 13.5177 17.8001\nSpatial Beta Diversity (Presence, quant=false) 0.7095 14.7190 20.7449\nTemporal Beta Diversity (Abundance, quant=true) 4.0110 114.5111 28.5494\nTemporal Beta Diversity (Abundance, quant=false) 1.3314 17.6840 13.2821\nTemporal Beta Diversity (Presence, quant=false) 1.2106 18.3145 15.1279\nDispersal-niche continuum index 53.4701 9162.7688 171.3625\nOccupied Patches Proportion 0.6862 14.9776 21.8266\nVariability Metrics 7.4703 141.9484 19.0017\nHypervolume Estimation 0.0034 0.0402 11.7786\nHypervolume Dissimilarity 0.0054 0.2190 40.7483","category":"page"},{"location":"Benchmarking/#Benchmarking-using-the-small-dataset","page":"Benchmarking Julia vs R","title":"Benchmarking using the small dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"All times are in millisecond (ms), and memory is in mebibytes (MiB). All values are rounded up to 4 decimal places.","category":"page"},{"location":"Benchmarking/#Julia-3","page":"Benchmarking Julia vs R","title":"Julia","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 0.0350 0.0423 0.0428 0.0793 0.0067 0.1225\nBeta Diversity (Abundance, quant=false) 0.0050 0.0115 0.0112 0.0360 0.0047 0.0883\nBeta Diversity (Presence, quant=false) 0.0048 0.0115 0.0113 0.0346 0.0045 0.0883\nSpatial Beta Diversity (Abundance, quant=true) 0.6158 0.6942 0.7670 3.3913 0.3912 1.1334\nSpatial Beta Diversity (Abundance, quant=false) 0.5008 0.5395 0.5717 3.3988 0.2870 0.7663\nSpatial Beta Diversity (Presence, quant=false) 0.4988 0.5296 0.5668 3.6272 0.3108 0.7663\nTemporal Beta Diversity (Abundance, quant=true) 3.4157 3.5487 3.8326 5.5600 0.6124 12.8811\nTemporal Beta Diversity (Abundance, quant=false) 0.8895 1.0069 1.1532 4.7410 0.5860 2.8937\nTemporal Beta Diversity (Presence, quant=false) 0.8746 0.9875 1.1156 5.7435 0.6782 2.8937\nDispersal-niche continuum index 12.3592 14.7842 13.9412 16.2559 1.2164 37.7604\nOccupied Patches Proportion 0.1983 0.2222 0.2643 1.6241 0.1684 0.3249\nVariability Metrics 2.4110 2.4428 2.5369 4.3091 0.3546 3.8483\nHypervolume Estimation 0.0028 0.0031 0.0035 0.0426 0.0040 0.0059\nHypervolume Dissimilarity 0.0048 0.0056 0.0063 0.0720 0.0067 0.0082","category":"page"},{"location":"Benchmarking/#R-3","page":"Benchmarking Julia vs R","title":"R","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Time_minimum Time_median Time_mean Time_maximum Time_std memory\nBeta Diversity (Abundance, quant=true) 1.1577 1.5902 2.1087 10.1530 1.4055 0.0195\nBeta Diversity (Abundance, quant=false) 0.2662 0.3371 0.5438 1.8151 0.3854 0.0444\nBeta Diversity (Presence, quant=false) 0.2606 0.3569 0.5201 1.1688 0.2659 0.0444\nSpatial Beta Diversity (Abundance, quant=true) 11.9829 16.8506 23.9044 622.2835 60.6749 1.2097\nSpatial Beta Diversity (Abundance, quant=false) 8.4718 12.0729 12.5712 23.3589 2.9096 0.7667\nSpatial Beta Diversity (Presence, quant=false) 8.4567 11.8902 11.9560 20.2556 2.5048 0.7667\nTemporal Beta Diversity (Abundance, quant=true) 74.1172 98.1867 124.9184 848.6431 123.4590 15.4311\nTemporal Beta Diversity (Abundance, quant=false) 12.3936 17.6707 22.9253 411.9853 40.0099 3.7200\nTemporal Beta Diversity (Presence, quant=false) 11.4340 16.1048 16.5250 22.9118 2.8710 3.7200\nDispersal-niche continuum index 3940.5316 4616.0343 4861.0437 16822.0133 1369.1769 912.5856\nOccupied Patches Proportion 10.3292 15.5675 24.8453 821.6664 80.6197 0.4902\nVariability Metrics 27.9684 43.4103 58.6905 820.6562 92.9202 10.5805\nHypervolume Estimation 0.0279 0.0465 0.0652 0.2666 0.0523 0.0003\nHypervolume Dissimilarity 0.1456 0.1991 0.3145 1.4536 0.2514 0.0014","category":"page"},{"location":"Benchmarking/#Speedup-3","page":"Benchmarking Julia vs R","title":"Speedup","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"TestCase Timemedianjulia Timemedianr Speedup\nBeta Diversity (Abundance, quant=true) 0.0423 1.5902 37.6006\nBeta Diversity (Abundance, quant=false) 0.0115 0.3371 29.3155\nBeta Diversity (Presence, quant=false) 0.0115 0.3569 31.0334\nSpatial Beta Diversity (Abundance, quant=true) 0.6942 16.8506 24.2731\nSpatial Beta Diversity (Abundance, quant=false) 0.5395 12.0729 22.3779\nSpatial Beta Diversity (Presence, quant=false) 0.5296 11.8902 22.4529\nTemporal Beta Diversity (Abundance, quant=true) 3.5487 98.1867 27.6683\nTemporal Beta Diversity (Abundance, quant=false) 1.0069 17.6707 17.5490\nTemporal Beta Diversity (Presence, quant=false) 0.9875 16.1048 16.3087\nDispersal-niche continuum index 14.7842 4616.0343 312.2269\nOccupied Patches Proportion 0.2222 15.5675 70.0713\nVariability Metrics 2.4428 43.4103 17.7706\nHypervolume Estimation 0.0031 0.0465 14.8715\nHypervolume Dissimilarity 0.0056 0.1991 35.6574","category":"page"},{"location":"Benchmarking/#Remarks","page":"Benchmarking Julia vs R","title":"Remarks","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Speedup is calculated as the R median execution time divided by the Julia median execution time. \nFor DNCI_multigroup_result, 100 permutations are used in both the julia and R function.","category":"page"},{"location":"Benchmarking/#The-Scripts-Used-for-Benchmarking","page":"Benchmarking Julia vs R","title":"The Scripts Used for Benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"Julia\nR","category":"page"},{"location":"Benchmarking/#Packages-used-for-benchmarking","page":"Benchmarking Julia vs R","title":"Packages used for benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmarking Julia vs R","title":"Benchmarking Julia vs R","text":"bench\nBenchmarkTools.jl","category":"page"},{"location":"DNCI/#Dispersal-Niche-Continuum-Index-(DNCI)-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The Dispersal-Niche Continuum Index (DNCI) functions in MetaCommunityMetrics quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. The function DNCI_multigroup  in this package is adapted from the R package DNCImper: Assembly process identification based on SIMPER analysis. These methods, originally developed by Clarke(1993) and later refined by Gibert & Escarguel(2019) and Vilmi et al.(2021), offer powerful tools for identifying the processes underlying species assembly in metacommunities. ","category":"page"},{"location":"DNCI/#Background","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Background","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions is built around the Per-SIMPER and DNCI analyses. PerSIMPER, based on the Similarity Percentage (SIMPER) analysis developed by Clarke (1993), assesses the contribution of individual taxa to overall dissimilarity (OAD) between groups of assemblages. PerSIMPER enhances this by comparing empirical SIMPER plots with randomized plots generated through matrix permutation, which helps identify whether niche, dispersal, or both processes are driving community assembly.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI (Dispersal-Niche Continuum Index) further extends this approach by transforming the qualitative results of PerSIMPER into a quantitative index, providing a straightforward measure of the influence of niche and dispersal processes on community structure.","category":"page"},{"location":"DNCI/#Functionality-Overview","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Functionality Overview","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions in MetaCommunityMetrics allow you to analyze the processes driving species assembly within your dataset. By comparing empirical data with randomized permutations, one can determine the extent to which niche and dispersal processes influence the structure of metacommunities. Before calculating the DNCI, groupings of sites (clusters) are required, as the DNCI relies on analyzing community composition across spatial groups. This package provides a function to perform the necessary clustering, which is not available in the equivalent R package. When the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. In contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. If the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.","category":"page"},{"location":"DNCI/#The-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"The Functions","text":"","category":"section"},{"location":"DNCI/#MetaCommunityMetrics.create_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::Vector{Int}, latitude::Vector{Float64}, longitude::Vector{Float64}, patch::Vector{Int}, total_richness::Vector{Int}) -> Dict{Int, DataFrame}\n\nThis function creates clusters (groupings of patches/sites) for each unique time step in a dataset which can then used for calculating DNCI. Only presnece-absence data can be used. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ntime::Vector: A vector indicating the time each sample was taken.\nlatitude::Vector: A vector indicating the latitude of each sample.\nlongitude::Vector: A vector indicating the longitude of each sample.\npatch::Vector: A vector indicating the spatial location (patch) of each sample. At least 10 patches are required for clustering.\ntotal_richness::Vector: A vector indicating the total species richness at each plot at each time step.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key represents a unique time point from the input data, with the corresponding value being a DataFrame for that time step. Each DataFrame contains the following columns: Time, Latitude, Longitude, Patch, Total_Richness, and Group (indicating the assigned cluster).\n\nDetails This function performs hierarchical clustering on the geographical coordinates of sampling patches/sites at each unique time step, assuming that organism dispersal occurs within the study region. It incorporates checks and adjustments to ensure the following conditions are met: at least 2 clusters, a minimum of 5 patches/sites per cluster, and that the variation in the number of taxa/species and patches/sites per group does not exceed 40% and 30%, respectively. These conditions are critical for calculating an unbiased DNCI value, and the function will issue warnings if any are not fulfilled.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 15×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 18×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#MetaCommunityMetrics.plot_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(latitude::Vector{Float64}, longitude::Vector{Float64}, group::Union{AbstractVector, String}, output_file=\"clusters.svg\") -> String\n\nVisualizes clustering results by generating an SVG image displaying the geographic coordinates and cluster assignments of patches/sites.\n\nArguments\n\nlatitude::Vector{Float64}: A vector of latitude coordinates of the patches/sites.\nlongitude::Vector{Float64}: A vector of longitude coordinates of the patches/sites.\ngroup::Union{AbstractVector, String}: A vector or string indicating the cluster assignments for each data point.\noutput_file::String=\"clusters.svg\": The filename for the output SVG visualization. Default is \"clusters.svg\".\n\nReturns\n\nString: The path to the created SVG file.\n\nDetails\n\nThe function generates a standalone SVG file that can be viewed in any web browser or image viewer.\nEach cluster is assigned a unique color, and patches/sites are plotted based on their geographic coordinates.\nThe visualization includes a legend identifying each cluster.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2545×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2542 │    10                  117     -108.5      35.5               3\n 2543 │    12                  117     -107.5      35.5               6\n 2544 │    16                  117     -108.5      36.0               4\n 2545 │    23                  117     -108.0      36.5               5\n                                                       2536 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> plot_clusters(clustering_result[1].Latitude, clustering_result[1].Longitude, clustering_result[1].Group; output_file=\"clusters.svg\")\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"This plot shows the clustering result for time step 1 based on geographic coordinates: (Image: Cluster Plot)","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.DNCI_multigroup","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000; count::Bool=true) -> DataFrame\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021). The DNCI quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. Please remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix. You can use the create_clusters function to generate the group membership.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\ncount::Bool=true: A flag indicating whether the numeber of permutations is printed. Default is false.\n\nReturns\n\nDataFrame: A DataFrame containing the DNCI value, the associate confiden interval (CI_DNCI) and variance (S_DNCI) for each pair of groups.\n\nDetails\n\nThe function calculates the DNCI for each pair of groups in the input data.\nWhen the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. \nIn contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. \nIf the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.\nPlease remove singletons (taxa/species that occuring at one patch/site within a time step) before using this function.\nThis function is a translation/adaptation of a function from the R package DNCImper, licensed under GPL-3.\nOriginal package and documentation available at: https://github.com/Corentin-Gibert-Paleontology/DNCImper\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Random\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> total_presence_df=@pipe df|>\n                        groupby(_,[:Species,:Sampling_date_order])|>\n                        combine(_,:Presence=>sum=>:Total_Presence) |>\n                        filter(row -> row[:Total_Presence] > 1, _)\n791×3 DataFrame\n Row │ Species  Sampling_date_order  Total_Presence \n     │ String3  Int64                Int64          \n─────┼──────────────────────────────────────────────\n   1 │ BA                        41               2\n   2 │ BA                        50               2\n   3 │ BA                        51               8\n   4 │ BA                        52              19\n   5 │ BA                        53              18\n  ⋮  │    ⋮              ⋮                 ⋮\n 787 │ SH                        56               3\n 788 │ SH                        60               4\n 789 │ SH                        70               3\n 790 │ SH                        73               5\n 791 │ SH                       117               4\n                                    781 rows omitted\n\njulia> total_richness_df= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  groupby(_,[:plot,:Sampling_date_order,:Longitude, :Latitude])|>\n                  combine(_,:Presence=>sum=>:Total_Richness)|>\n                  filter(row -> row[:Total_Richness] > 0, _) \n\n2565×5 DataFrame\n  Row │ plot   Sampling_date_order  Longitude  Latitude  Total_Richness \n      │ Int64  Int64                Float64    Float64   Int64          \n──────┼─────────────────────────────────────────────────────────────────\n    1 │     1                   41     -110.0      35.0               5\n    2 │     2                   41     -109.5      35.0               4\n    3 │     4                   41     -108.5      35.0               2\n    4 │     8                   41     -109.5      35.5               2\n    5 │     9                   41     -109.0      35.5               3\n  ⋮   │   ⋮             ⋮               ⋮         ⋮            ⋮\n 2561 │     9                  117     -109.0      35.5               5\n 2562 │    10                  117     -108.5      35.5               3\n 2563 │    12                  117     -107.5      35.5               6\n 2564 │    16                  117     -108.5      36.0               4\n 2565 │    23                  117     -108.0      36.5               5\n                                                       2555 rows omitted\n\njulia> clustering_result = create_clusters(total_richness_df.Sampling_date_order, total_richness_df.Latitude, total_richness_df.Longitude, total_richness_df.plot, total_richness_df.Total_Richness)\nDict{Int64, DataFrame} with 117 entries:\n  5   => 17×6 DataFrame…\n  56  => 23×6 DataFrame…\n  55  => 24×6 DataFrame…\n  35  => 23×6 DataFrame…\n  110 => 24×6 DataFrame…\n  114 => 22×6 DataFrame…\n  60  => 24×6 DataFrame…\n  30  => 20×6 DataFrame…\n  32  => 22×6 DataFrame…\n  6   => 19×6 DataFrame…\n  67  => 23×6 DataFrame…\n  45  => 23×6 DataFrame…\n  117 => 24×6 DataFrame…\n  73  => 23×6 DataFrame…\n  ⋮   => ⋮\n\njulia> println(clustering_result[1])\n14×6 DataFrame\n Row │ Time   Latitude  Longitude  Patch  Total_Richness  Group \n     │ Int64  Float64   Float64    Int64  Int64           Int64 \n─────┼──────────────────────────────────────────────────────────\n   1 │     1      35.0     -110.0      1               1      1\n   2 │     1      35.0     -109.5      2               1      1\n   3 │     1      35.5     -109.5      8               1      1\n   4 │     1      35.5     -109.0      9               1      1\n   5 │     1      35.5     -108.0     11               2      2\n   6 │     1      36.0     -109.5     14               2      1\n   7 │     1      36.0     -108.0     17               1      2\n   8 │     1      36.5     -108.5     22               1      2\n   9 │     1      35.0     -107.5      6               1      2\n  10 │     1      36.0     -110.0     13               1      1\n  11 │     1      36.0     -109.0     15               1      1\n  12 │     1      36.5     -109.5     20               1      1\n  13 │     1      36.5     -109.0     21               1      2\n  14 │     1      36.5     -108.0     23               1      2\n\njulia> comm= @pipe df|>\n                  innerjoin(_,  total_presence_df, on = [:Species, :Sampling_date_order], makeunique = true) |>\n                  innerjoin(_,  total_richness_df, on = [:plot, :Sampling_date_order], makeunique = true) |>\n                  filter(row -> row[:Sampling_date_order] == 1, _) |>\n                  select(_, [:plot, :Species, :Presence]) |>\n                  unstack(_, :Species, :Presence, fill=0) |>\n                  select(_, Not(:plot)) |>\n                  Matrix(_)\n14×3 Matrix{Int64}:\n 1  0  0\n 1  0  0\n 1  0  0\n 1  0  0\n 1  1  0\n 1  1  0\n 1  0  0\n 0  0  1\n 0  1  0\n 0  1  0\n 1  0  0\n 0  1  0\n 0  0  1\n 0  0  1\n\njulia> Random.seed!(1234) \n\njulia> DNCI_result = DNCI_multigroup(comm, clustering_result[1].Group, 1000; count = false)\n1×5 DataFrame\n Row │ group1  group2  DNCI      CI_DNCI  S_DNCI  \n     │ Int64   Int64   Float64   Float64  Float64 \n─────┼────────────────────────────────────────────\n   1 │      1       2  0.045603  6.52576  3.26288\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#References","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"References","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"Clarke, K. R. Non-parametric multivariate analyses of changes in community structure. Australian Journal of Ecology 18, 117-143 (1993). https://doi.org:https://doi.org/10.1111/j.1442-9993.1993.tb00438.x\nGibert, C. & Escarguel, G. PER-SIMPER—A new tool for inferring community assembly processes from taxon occurrences. Global Ecology and Biogeography 28, 374-385 (2019). https://doi.org:https://doi.org/10.1111/geb.12859\nVilmi, A. et al. Dispersal–niche continuum index: a new quantitative metric for assessing the relative importance of dispersal versus niche processes in community assembly. Ecography 44, 370-379 (2021). https://doi.org:https://doi.org/10.1111/ecog.05356","category":"page"},{"location":"Hypervolume/#Hypervolume-Functions","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Hypervolume is a method originally proposed by Hutchinson (1957). It provide methods to calculate the volume of a niche for a given specice and thus the ncihe overlap between two species. It helps to infer how niche breath of species has contribute to the co-occurance of different species in the same location at the same time. The hypervolume functions provide by this package are adapted from the R package MVNH (https://github.com/lvmuyang/MVNH).","category":"page"},{"location":"Hypervolume/#An-Overview","page":"Hypervolume Functions","title":"An Overview","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The MVNH framework provides parametric measures for analyzing ecological niches using the multivariate normal distribution model. This framework offers powerful tools for quantifying and comparing the size and dissimilarity of species' niches, with each measure being partitionable into biologically meaningful components.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The framework models a species' niche as a multivariate normal distribution in environmental space, where:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Each environmental variable represents one dimension of the niche.\nThe mean vector represents the niche optimum.\nThe covariance matrix represents the niche breadth and shape.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"There are four hypervolume functions in this package:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"MVNH_det calculates the total hypervolume of a species' niche based on the determinant of the covariance matrix (generalized variance). This measure can be partitioned into:\nMVNH_dissimilarity calculates the Bhattacharyya distance between two species' niches, providing a comprehensive measure of niche differentiation. \naverage_MVNH_det calculates the mean hypervolume across multiple species in a community, providing an overall measure of niche size at the community level.\naverage_MVNH_dissimilarity calculates the mean Bhattacharyya distance between all unique pairs of species in a community, providing a measure of overall niche differentiation.","category":"page"},{"location":"Hypervolume/#Practical-Considerations","page":"Hypervolume Functions","title":"Practical Considerations","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Statistical assumptions: This framework relies on multivariate normal distribution of environmental data.\nWhen encountering skewed variables, apply appropriate transformations to normalize distributions.\nBe aware that as you increase the number of variables, you face greater challenges with:\nVariable interdependence (collinearity) which can drive determinant values toward zero\nPotential violations of the multivariate normality assumption\nAddress variable interdependence through either:\nThoughtful pre-selection of ecologically meaningful variables with direct influence on species distributions\nApplication of dimension reduction methods such as PCA (principal component analysis)\nImportant note: PCA creates orthogonal axes, which forces the correlation component to 1.0, eliminating correlation structure information.\nFor datasets containing multiple distinct groups of related environmental variables (such as climate factors, soil properties, or topographic features), consider using generalized canonical variables to identify the most representative variables within each natural category while preserving the ecological relationships between different variable groups.\nMeasurement standardization: Before analysis, standardize all environmental variables to comparable scales to prevent variables with larger numerical ranges from disproportionately influencing results.","category":"page"},{"location":"Hypervolume/#The-Functions","page":"Hypervolume Functions","title":"The Functions","text":"","category":"section"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_det","text":"MVNH_det(data::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate the niche hypervolume of a species based on environmental variables.\n\nArguments\n\ndata::DataFrame: DataFrame where each row represents an observation of a species (presence only, need to filter out absences) and columns represent environmental variables.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A DataFrame containing:\nCorrelation: The correlation component (calculated as det(COV)/prod(variances))\nOne column for each environmental variable showing its variance\ntotal: The total hypervolume (calculated as the determinant of the covariance matrix)\n\nDetails\n\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\nThe function computes the covariance matrix of the input data, extracts variances, and calculates the determinant\nThis function is a Julia implementation of the MVNH_det function from the R package MVNH (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics, UnicodePlots\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n143×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> result = MVNH_det(data; var_names=[\"Temperature\", \"Precipitation\"])\n1×4 DataFrame\n Row │ total    correlation  Temperature  Precipitation \n     │ Float64  Float64      Float64      Float64       \n─────┼──────────────────────────────────────────────────\n   1 │ 1.15268     0.999732     0.962495        1.19792\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_dissimilarity","text":"MVNH_dissimilarity(data_1::DataFrame, data_2::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate niche dissimilarity between two species based on their environmental variables, using the Bhattacharyya distance and its components.\n\nArguments\n\ndata_1::DataFrame: DataFrame for the first species, where each row represents an observation (presence only, need to filter out absences) and columns represent environmental variables.\ndata_2::DataFrame: DataFrame for the second species, with the same structure as data_1.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A dataframe containing three metrics and their components:\n\"Bhattacharyya_distance\": The total Bhattacharyya distance and its components\n\"Mahalanobis_distance\": The Mahalanobis component of the Bhattacharyya distance\n\"Determinant_ratio\": The determinant ratio component of the Bhattacharyya distance\nEach metric contains:\ntotal: The total value of the respective distance measure\ncorrelation: The correlation component of the distance measure\nOne value for each environmental variable showing its contribution to the distance\n\nDetails\n\nThe Bhattacharyya distance is calculated as the sum of two components:\nMahalanobis component: (1/8) × (μ₁-μ₂)ᵀ × (S₁+S₂)/2⁻¹ × (μ₁-μ₂)\nDeterminant ratio component: (1/2) × log(det((S₁+S₂)/2) / sqrt(det(S₁) × det(S₂)))\nEach component is further decomposed into individual variable contributions and correlation effects\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\nThis function is a Julia implementation inspired by the MVNH R package (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n\njulia> data_1 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n\n143×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> data_2 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"SH\", _) |>\n            select(_, [:normalized_temperature, :normalized_precipitation])\n58×2 DataFrame\n Row │ normalized_temperature  normalized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │              -0.229864                  1.84371\n   2 │               0.460218                 -0.624328\n   3 │              -1.03283                  -1.16451\n   4 │               0.675006                 -0.120586\n   5 │               0.40729                   0.20034\n  ⋮  │           ⋮                        ⋮\n  54 │              -0.870299                 -0.235392\n  55 │               0.504555                 -1.50887\n  56 │               2.03065                  -0.740789\n  57 │              -0.174396                  0.448461\n  58 │               0.547169                  1.03257\n                                         48 rows omitted\n                   \njulia> result = MVNH_dissimilarity(data_1, data_2; var_names=[\"Temperature\", \"Precipitation\"])\n3×5 DataFrame\n Row │ metric                  total       correlation  Temperature  Precipitation \n     │ String                  Float64     Float64      Float64      Float64       \n─────┼─────────────────────────────────────────────────────────────────────────────\n   1 │ Bhattacharyya_distance  0.00980771  0.00015205    0.00388058     0.00577508\n   2 │ Mahalanobis_distance    0.00664862  5.06232e-6    0.00234902     0.00429454\n   3 │ Determinant_ratio       0.00315908  0.000146988   0.00153156     0.00148054\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_det","text":"average_MVNH_det(data::DataFrame, presence_absence::Vector{Int}, species::Vector{String}; \n                 var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche hypervolume across multiple species in a community dataset.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Vector{String}: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average hypervolume across all species with presence data.\n\nDetails\n\nFor each unique species, the function:\nFilters observations where the species is present (presence_absence > 0)\nCalculates the niche hypervolume using the MVNH_det function\nExtracts the total hypervolume value\nThe function then computes the mean of all individual species hypervolumes\nSpecies with no presence data are skipped in the calculation\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:normalized_temperature, :normalized_precipitation])\n           \n53352×2 DataFrame\n   Row │ normalized_temperature  normalized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_det(data, df.Presence, String.(df.Species); var_names=[\"Temperature\", \"Precipitation\"])\n1.2103765096417536\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_dissimilarity","text":"average_MVNH_dissimilarity(data::DataFrame, presence_absence::Vector{Int}, species::Union{Integer, String, PooledArrays.PooledVector}; \n                          var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche dissimilarity between all unique pairs of species in a community dataset using Bhattacharyya distance.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::Vector{String}: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average Bhattacharyya distance across all unique species pairs.\n\nDetails\n\nFor each unique pair of species, the function:\nFilters observations where each species is present (presence_absence > 0)\nCalculates the niche dissimilarity using the MVNH_dissimilarity function\nExtracts the total Bhattacharyya distance value\nThe function then computes the mean of all pairwise Bhattacharyya distances\nSpecies pairs where either species has no presence data are skipped\nEach species pair is processed only once (i.e., sp1-sp2 is calculated, but sp2-sp1 is skipped)\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be normalized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  normalized_temperature  normalized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:normalized_temperature, :normalized_precipitation])    \n53352×2 DataFrame\n   Row │ normalized_temperature  normalized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_dissimilarity(data, df.Presence, String.(df.Species); var_names=[\"Temperature\", \"Precipitation\"])     \n0.03059942936454443\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#References","page":"Hypervolume Functions","title":"References","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Lu, Muyang, Kevin Winner, and Walter Jetz. A unifying framework for quantifying and comparing n‐dimensional hypervolumes. Methods in Ecology and Evolution 12.10, 1953-1968 (2021). https://doi.org/10.1111/2041-210X.13665","category":"page"}]
}
