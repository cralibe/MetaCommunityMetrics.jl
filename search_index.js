var documenterSearchIndex = {"docs":
[{"location":"NicheOverlapIndex/#Niche-Overlap-Index-Function","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"Niche overlap refers to the extent to which different species use the same resources or occupy similar ecological niches. High niche overlap might indicate intense competition, whereas low overlap suggests niche differentiation, allowing species to coexist by minimizing direct competition.","category":"page"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"To capture the changes in density-independent abiotic response, also known as niche breadth, this implementation uses Pianka's Niche Overlap Index, as suggested by Pianka (1973). The summary statistics of this index include the mean, maximum, and minimum values across all species pairs, providing a comprehensive understanding of niche sharing within the community.","category":"page"},{"location":"NicheOverlapIndex/#Functionality-Overview","page":"Niche Overlap Index Function","title":"Functionality Overview","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"The Niche Overlap Index functions in MetaCommunityMetrics provide a robust framework for calculating niche overlap based on species abundance or presence-absence data. These functions allow you to evaluate how species share ecological space within a metacommunity, offering valuable insights into community dynamics and species interactions.","category":"page"},{"location":"NicheOverlapIndex/#The-Function","page":"Niche Overlap Index Function","title":"The Function","text":"","category":"section"},{"location":"NicheOverlapIndex/#MetaCommunityMetrics.niche_overlap","page":"Niche Overlap Index Function","title":"MetaCommunityMetrics.niche_overlap","text":"niche_overlap(abundance::AbstractVector, species::AbstractVector, site::AbstractVector, time::AbstractVector) -> DataFrame\n\nCalculates the overall mean, maximum, and minimum values of the niche overlap index from all species pairs in the provided data.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\nspecies::AbstractVector: Vector representing species names or IDs. \nsite::AbstractVector: Vector representing site names or IDs. \ntime::AbstractVector: Vector representing sampling dates. \n\nDescription\n\nThe niche overlap index is calculated based on the method suggested by Pianka (1973), with the assumption that the proportional use of resources by a species at a specific site and time is equivalent to its relative abundance at that location and time period across all sampled sites and times.\n\nReturns\n\nDataFrame: A DataFrame containing the overall mean, maximum, and minimum values of the niche overlap index from all species pairs.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> result = niche_overlap(df.Abundance, df.Species, df.plot, df.Sampling_date_order)\n1×3 DataFrame\n Row │ mean_niche_overlap_index  min_niche_overlap_index  max_niche_overlap_index \n     │ Float64                   Float64                  Float64                 \n─────┼────────────────────────────────────────────────────────────────────────────\n   1 │                0.0923816                      0.0                 0.406837\n\n\n\n\n\n","category":"function"},{"location":"NicheOverlapIndex/#References","page":"Niche Overlap Index Function","title":"References","text":"","category":"section"},{"location":"NicheOverlapIndex/","page":"Niche Overlap Index Function","title":"Niche Overlap Index Function","text":"MacArthur, R. & Levins, R. The limiting similarity, convergence, and divergence of coexisting species. The American Naturalist 101, 377-385 (1967). \nPianka, E. R. (1974). \"Niche overlap and diffuse competition.\" Proceedings of the National Academy of Sciences, 71(5), 2141-2145.\nPianka, E. R. (1973). \"The Structure of Lizard Communities.\" Annual Review of Ecology and Systematics, 4(1), 53-74.","category":"page"},{"location":"Validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"We validate all the calcuations in MetaCommunityMetrics that have equvilant functions in R to make sure the functions in MetaCommunityMetrics are correct and accurate as the equvilant functions in R. All validation results are presented to 4 decimal places (±0.0001) here. Floating-point differences between implementations smaller than 0.0001 were considered negligible for both statistical and ecological applications of these metrics.","category":"page"},{"location":"Validation/#Validation-Result","page":"Validation","title":"Validation Result","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Below is a comparison of the results between MetaCommunityMetrics and functions/equivalent implementation in R.","category":"page"},{"location":"Validation/#Beta-Diversity","page":"Validation","title":"Beta Diversity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here. All values *","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"TestCase BDtotal Repl RichDif\nBeta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nBeta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nBeta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nSpatial Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=true) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Abundance, quant=false) 0.0000 0.0000 0.0000\nTemporal Beta Diversity (Presence, quant=false) 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Dispersal-niche-continuum-index","page":"Validation","title":"Dispersal-niche continuum index","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"*A plot showing the distribution of the DNCI values of diffent group pairs from R and Julia, each pair are ran for 100 times, with 1000 permutations each time. (Image: Julia vs. R)","category":"page"},{"location":"Validation/#Occupied-Patches-Proportion","page":"Validation","title":"Occupied Patches Proportion","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"minproppatches meanproppatches maxproppatches\n0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Variability-Metrics","page":"Validation","title":"Variability Metrics","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/","page":"Validation","title":"Validation","text":"CVSL CVCL CVSR CVCR\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Hypervolume","page":"Validation","title":"Hypervolume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Absolute Differences between the results from MetaCommunityMetrics and the equvilant functions in R are shown here.","category":"page"},{"location":"Validation/#Volume","page":"Validation","title":"Volume","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"total correlation Temperature Precipitation\n0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Volume-dissimilarity","page":"Validation","title":"Volume dissimilarity","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"Metric total correlation Temperature Precipitation\nBhattacharyya_distance 0.0000 0.0000 0.0000 0.0000\nMahalanobis_distance 0.0000 0.0000 0.0000 0.0000\nDeterminant_ratio 0.0000 0.0000 0.0000 0.0000","category":"page"},{"location":"Validation/#Running-Validation","page":"Validation","title":"Running Validation","text":"","category":"section"},{"location":"Validation/","page":"Validation","title":"Validation","text":"The script to run this validation result can be found here.","category":"page"},{"location":"OccupiedPatchesProportion/#Occupied-Patches-Proportion-Function","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion function in MetaCommunityMetrics provides a simple yet powerful metric for understanding the distribution and prevalence of species across different habitat patches within a metacommunity. By calculating the averaged, minmum and maximum proportion of patches occupied across species, this function helps ecologists assess the spatial extent of species distributions and identify potential patterns of rarity or commonness across the landscape.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"This function draws on the concepts discussed by Ehrlén & Eriksson (2000) in their study on dispersal limitation and patchy occupancy in forest herbs. According to their findings, low occupancy may indicate dispersal limitation or strong competition, while high occupancy could suggest mass effects due to high dispersal rates or the ability to thrive in various conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#An-Overview","page":"Occupied Patches Proportion Function","title":"An Overview","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"The Occupied Patches Proportion metric quantifies the averaged proportion of habitat patches in which a species is present. This information is crucial for understanding species distributions, particularly in fragmented landscapes or patchy environments where species may not occupy all available habitat. This metric can be used to identify widespread species, which occupy a large number of patches, as well as rare species, which are restricted to only a few patches.","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"After calculating the proportion of patches occupied for each species, the mean, minimum, and maximum proportion of patches occupied can be derived. These values are valuable indicators of ecological processes:","category":"page"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Low proportion of patches occupied: May indicate dispersal limitation or strong competition among species. Such patterns could suggest that certain species struggle to colonize or persist in many patches.\nHigh proportion of patches occupied: May point to mass effects, where species are abundant in many patches, possibly due to high dispersal rates or the ability to thrive across a range of conditions.","category":"page"},{"location":"OccupiedPatchesProportion/#The-Function","page":"Occupied Patches Proportion Function","title":"The Function","text":"","category":"section"},{"location":"OccupiedPatchesProportion/#MetaCommunityMetrics.prop_patches","page":"Occupied Patches Proportion Function","title":"MetaCommunityMetrics.prop_patches","text":"prop_patches(presence::AbstractVector, species::AbstractVector, site::AbstractVector) -> DataFrame\n\nCalculate the proportion of patches occupied by each species and summarize the results.\n\nThis function takes three vectors: presence, species, and patch, and performs the following steps:\n\nArguments\n\npresence::AbstractVector: Vector representing the occurence of species.\nspecies::AbstractVector: Vector representing species names or IDs.\nsite::AbstractVector: Vector representing site names or IDs.\n\nReturns\n\nDataFrame: A DataFrame containing the mean, minimum, and maximum proportion of patches               occupied across all species.\n\nExample\n\njulia> using MetaCommunityMetrics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n                                                                                          \njulia> prop_patches(df.Presence, df.Species, df.plot)\n1×3 DataFrame\n Row │ mean_prop_patches  min_prop_patches  max_prop_patches \n     │ Float64            Float64           Float64          \n─────┼───────────────────────────────────────────────────────\n   1 │          0.734649         0.0833333               1.0\n\n\n\n\n\n","category":"function"},{"location":"OccupiedPatchesProportion/#References","page":"Occupied Patches Proportion Function","title":"References","text":"","category":"section"},{"location":"OccupiedPatchesProportion/","page":"Occupied Patches Proportion Function","title":"Occupied Patches Proportion Function","text":"Ehrlén, J., & Eriksson, O. (2000). Dispersal Limitation and Patchy Occupancy in Forest Herbs. Ecology, 81(6), 1667-1674. https://doi.org:https://doi.org/10.1890/0012-9658(2000)081[1667:DLAPOI]2.0.CO;2","category":"page"},{"location":"#MetaCommunityMetrics.jl","page":"Home","title":"MetaCommunityMetrics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A collection of tools and utilities for analyzing metacommunities in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MetaCommunityMetrics. Here you can find guides and reference material on how to use the functions.","category":"page"},{"location":"#An-Overview","page":"Home","title":"An Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a comprehensive toolkit designed to characterize the spatiotemporal structure and dynamics of a metacommunity—a network of communities linked by the dispersal of multiple, interacting species, each with unique niche breadths. It includes functions to calculate a range of specific metrics, which have been previously implemented in R and proven valuable for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, they come with high computational costs, especially for large species community datasets. To address this issue, MetaCommunityMetrics.jl was developed in Julia, a programming language known for its efficiency in handling computationally intensive tasks. This implementation significantly improves the efficiency of calculating these metrics, making it a powerful tool for metacommunity analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beta diversity decompositions in space/time: total diversity, species replacement (turnover), and richness differences for both presence-absence and abundance data\nDispersal-niche continuum index to evaluate the degree to which communities are influenced by dispersal processes and niche breadth\nNiche overlap indices to determine the extent of niche sharing among species within the metacommunity\nThe proportion of habitat patches occupied by each species\nThe variability of community composition across different spatial and temporal scales\nNiche hypervolume measurements (individual species, average, and between-species dissimilarities)","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MetaCommunityMetrics, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"MetaCommunityMetrics\")","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Beta Diversity\nDNCI\nNiche Overlap Index\nOccupied Patches Proportion\nVariability Metrics\nHypervolume","category":"page"},{"location":"#Comparison-between-Julia-and-R-implementations","page":"Home","title":"Comparison between Julia and R implementations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Validation\nBenchmarking","category":"page"},{"location":"#Accessing-the-Sample-Data-for-exploring-the-functions","page":"Home","title":"Accessing the Sample Data for exploring the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package utilizes rodent data from the Portal Project, a long-term study of a Chihuahuan desert ecosystem (available at https://github.com/weecology/portalr), as sample data for testing and benchmarking functions between Julia and R. The original rodent abundance data were collected monthly across 24 plots, recording a total of 21 species. For the purposes of this package, the data are filtered for the period from 2010 to 2023, transformed into long format, and species that were not recorded during this period are removed. Additionally, plots with no observations during the whole sampling period are excluded. A new column, Sampling_date_order, was created to sequentially number the sampling dates, starting at 1 and continuing through 117, to facilitate analysis. The locations of the plots (Latitude and Longitude) were simulated for testing the DNCI functions. The temperature and precipatation data were simulated for testing the hypervolume functions. The scripts to download and wrangle the original data can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Downloading the rodent data\nData Wrangling","category":"page"},{"location":"","page":"Home","title":"Home","text":"To assess the sample data, use the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MetaCommunityMetrics\n\nload_sample_data()","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using MetaCommunityMetrics\n\njulia> load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                   Float64                    \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                  0.829467                -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5                 -1.12294                 -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5                 -0.409808                -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5                 -1.35913                 -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                  0.0822                   1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                 ⋮                          ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0                 -0.571565                -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5                 -2.33729                 -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                  0.547169                 1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5                 -0.815015                 0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                  0.48949                 -1.59416\n                                                                                                                                                53342 rows omitted","category":"page"},{"location":"#Acknowledgment","page":"Home","title":"Acknowledgment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Acknowledgment","category":"page"},{"location":"BetaDiversity/#Beta-Diversity-Functions","page":"Beta Diverisity Functions","title":"Beta Diversity Functions","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Beta diversity is a fundamental concept in ecology that quantifies the variation in species composition between different plots, or over time. In the context of metacommunity analysis, beta diversity functions help to assess how community composition changes spatially across different locations or temporally within a metacommunity.","category":"page"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"The beta_diversity functions in MetaCommunityMetrics are adapted from the beta.div.comp function in the R package adespatial. These methods, originally developed by Pierre Legendre (2014), are implemented in Julia to provide a more efficient means of computation for large-scale datasets. The functions use indices from the Podani family, Jaccard-based indices, and Ruzicka-based indices to calculate total beta diversity and its components: replacement and richness difference.","category":"page"},{"location":"BetaDiversity/#Choosing-the-Right-Function","page":"Beta Diverisity Functions","title":"Choosing the Right Function","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Use beta_diversity for a general, comprehensive measure of beta diversity across your dataset. This function provides an overall assessment of how species composition varies between sites or over time, capturing both replacement (the turnover of species) and richness difference(the difference in species richness). \nUse spatial_beta_div to comparing diversity between different spatial locations of a metacommunity. \nUse temporal_beta_div to track how diversity changes over time of a metacommunity. ","category":"page"},{"location":"BetaDiversity/#The-Functions","page":"Beta Diverisity Functions","title":"The Functions","text":"","category":"section"},{"location":"BetaDiversity/#MetaCommunityMetrics.beta_diversity","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.beta_diversity","text":"beta_diversity(mat::Matrix; quant::Bool) -> DataFrame\n\nCalculate beta diversity for a given biodiversity data. This function supports both binary (presence/absence) and quantitative (abundance) data.\n\nArguments\n\nmat::Matrix: A matrix where each row represents a site and each column represents a species. The elements of the matrix should represent the presence/absence or abundance of species.\nquant::Bool: Specifies the data type for analysis. When false, treats data as binary presence/absence, converting any quantitative values and applying Jaccard-based indices. When true, treats data as quantitative abundance data and applies Ruzicka-based indices.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nBDtotal: Total beta diversity, which captures the overall dissimilarity between local communities.\nRepl: Replacement component of diversity, which reflects species turnover between sites: how much communities differ due to having different species compositions rather than different species counts.\nRichDif: Richness difference component of diversity, which captures differences in the number of species between communities.\n\nDetails\n\nEmpty sites (empty rows in the matrix) have to be removed before calculation.\nSpecies that did not occupy any sites in the data (empty columns in the matrix) have to be removed before calculation.\nThis function is a translation/adaptation of the beta.div.compfunction from the R packageadespatial`, licensed under GPL-3.\nOriginal package and documentation available at: https://cran.r-project.org/web/packages/adespatial/index.html\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                   Float64                    \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                  0.829467                -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5                 -1.12294                 -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5                 -0.409808                -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5                 -1.35913                 -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                  0.0822                   1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                 ⋮                          ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0                 -0.571565                -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5                 -2.33729                 -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                  0.547169                 1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5                 -0.815015                 0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                  0.48949                 -1.59416\n                                                                                                                                                53342 rows omitted\n\njulia> matrix_with_abundance = @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :standardized_temperature, :standardized_precipitation, :Presence)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |> \n           unstack(_, :Species, :Abundance, fill=0) |>  \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix\n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:] \n15×5 Matrix{Union{Missing, Int64}}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 2  0  0  0  0\n 1  0  0  1  0\n 4  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  2  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> matrix_with_presence =  @pipe df |> \n           select(_, Not(:Year, :Month, :Day, :Longitude, :Latitude, :standardized_temperature, :standardized_precipitation, :Abundance)) |> \n           filter(row -> row[:Sampling_date_order] == 1, _) |>\n           unstack(_, :Species, :Presence, fill=0) |> \n           select(_, Not(:Sampling_date_order, :plot)) |> \n           Matrix(_) |> #convert the dataframe to a matrix      \n           _[:, sum(_, dims=1)[1, :] .!= 0] |> \n           _[sum(_, dims=2)[:, 1] .!= 0,:]\n15×5 Matrix{Int64}:\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  0  0\n 1  0  0  1  0\n 1  0  0  1  0\n 1  0  0  0  0\n ⋮           \n 0  0  0  1  0\n 1  0  0  0  0\n 0  0  0  1  0\n 0  0  0  0  1\n 0  0  1  0  0\n 0  0  0  0  1\n\njulia> result_using_abanduce_data_1 = beta_diversity(matrix_with_abundance; quant=true)\n1×3 DataFrame\n Row │ BDtotal   Repl     RichDif  \n     │ Float64   Float64  Float64  \n─────┼─────────────────────────────\n   1 │ 0.390317   0.2678  0.122517\n\njulia> result_using_abanduce_data_2 = beta_diversity(matrix_with_abundance; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\njulia> result_using_binary_data = beta_diversity(matrix_with_presence; quant=false)\n1×3 DataFrame\n Row │ BDtotal   Repl      RichDif   \n     │ Float64   Float64   Float64   \n─────┼───────────────────────────────\n   1 │ 0.357143  0.284127  0.0730159\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.spatial_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.spatial_beta_div","text":"spatial_beta_div(abundance::AbstractVector, time::AbstractVector, site::AbstractVector, species::AbstractVector; quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in space based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance or occurence of species.\ntime::AbstractVector: Vector representing sampling dates.\nsite::AbstractVector: Vector representing site names or IDs.\nspecies::AbstractVector: Vector representing species names or IDs.\nquant::Bool: Specifies the data type for analysis. When false, treats data as binary presence/absence, converting any quantitative values and applying Jaccard-based indices. When true, treats data as quantitative abundance data and applies Ruzicka-based indices.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in space. Columns are spatial_BDtotal, spatial_Repl, and spatial_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components after aggregating .\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in space is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                   Float64                    \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                  0.829467                -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5                 -1.12294                 -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5                 -0.409808                -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5                 -1.35913                 -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                  0.0822                   1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                 ⋮                          ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0                 -0.571565                -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5                 -2.33729                 -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                  0.547169                 1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5                 -0.815015                 0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                  0.48949                 -1.59416\n                                                                                                                                                53342 rows omitted\n\njulia> result_using_abanduce_data_1 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.264822      0.121882         0.142939\n        \njulia> result_using_abanduce_data_2 = spatial_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\njulia> result_using_binary_data = spatial_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ spatial_BDtotal  spatial_Repl  spatial_RichDif \n     │ Float64          Float64       Float64         \n─────┼────────────────────────────────────────────────\n   1 │        0.133035       0.05976        0.0732746\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#MetaCommunityMetrics.temporal_beta_div","page":"Beta Diverisity Functions","title":"MetaCommunityMetrics.temporal_beta_div","text":"temporal_beta_div(abundance::AbstractVector, time::AbstractVector, site::AbstractVector, species::AbstractVector;quant::Bool) -> DataFrame\n\nCalculate the beta diversity decompositions of a metacommunity in time based on species abundances or presence-absences using the function beta_diversity.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance or occurence of species.\ntime::AbstractVector: Vector representing sampling dates.\nsite::AbstractVector: Vector representing site names or IDs.\nspecies::AbstractVector: Vector representing species names or IDs.\nquant::Bool: Specifies the data type for analysis. When false, treats data as binary presence/absence, converting any quantitative values and applying Jaccard-based indices. When true, treats data as quantitative abundance data and applies Ruzicka-based indices.\n\nReturns\n\nDataFrame: A DataFrame containing the values of total beta diversity, replacement, and richness difference components in time. Columns are temporal_BDtotal, temporal_Repl, and temporal_RichDif.\n\nDetails\n\nThis function uses the beta_diversity function to calculate beta diversity components for each site.\nFor binary data, the function calculates Podani family, Jaccard-based indices. \nFor quantitative data, the function calculates Podani family, Ruzicka-based indices.\nThe beta diversity decompositions of a metacommunity in time is a set of metrics suggested by Guzman et al. (2022) to infer metacommunity processes.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                   Float64                    \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                  0.829467                -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5                 -1.12294                 -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5                 -0.409808                -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5                 -1.35913                 -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                  0.0822                   1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                 ⋮                          ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0                 -0.571565                -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5                 -2.33729                 -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                  0.547169                 1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5                 -0.815015                 0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                  0.48949                 -1.59416\n                                                                                                                                                53342 rows omitted\n\njulia> result_using_abanduce_data_1 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=true)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.311222      0.0995483          0.211674\n        \njulia> result_using_abanduce_data_2 = temporal_beta_div(df.Abundance, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\njulia> result_using_binary_data = temporal_beta_div(df.Presence, df.Sampling_date_order, df.plot, df.Species; quant=false)\n1×3 DataFrame\n Row │ temporal_BDtotal  temporal_Repl  temporal_RichDif \n     │ Float64           Float64        Float64          \n─────┼───────────────────────────────────────────────────\n   1 │         0.206262      0.0693664          0.136895\n\n\n\n\n\n","category":"function"},{"location":"BetaDiversity/#References","page":"Beta Diverisity Functions","title":"References","text":"","category":"section"},{"location":"BetaDiversity/","page":"Beta Diverisity Functions","title":"Beta Diverisity Functions","text":"Guzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683\nLegendre, P. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography 23, 1324-1334 (2014). https://doi.org:https://doi.org/10.1111/geb.12207","category":"page"},{"location":"VariabilityMetrics/#Variability-Metrics-Functions","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The variability metrics functions in MetaCommunityMetrics are designed to capture changes in dispersal and density-dependent biotic interactions by investigating temporal variability and synchrony across spatial scales and organizational levels within a metacommunity. These functions are based on the work of Wang et al. (2019), which provides a framework for quantifying variability at different scales and contexts within a community.","category":"page"},{"location":"VariabilityMetrics/#An-Overview","page":"Variability Metrics Functions","title":"An Overview","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"In MetaCommunityMetrics, the CV_meta function is directly adapted from the R function var.partition in Wang et al. (2019).","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"The function provides four metrics that are designed to quantify variability at different scales and contexts within a metacommunity:","category":"page"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Local-scale average species variability (CV_s_l)\nRegional-scale average species variability (CV_s_r)\nLocal-scale average community variability (CV_c_l)\nRegional-scale community variability (CV_c_r)","category":"page"},{"location":"VariabilityMetrics/#The-Function","page":"Variability Metrics Functions","title":"The Function","text":"","category":"section"},{"location":"VariabilityMetrics/#MetaCommunityMetrics.CV_meta","page":"Variability Metrics Functions","title":"MetaCommunityMetrics.CV_meta","text":"CV_meta(abundance::AbstractVector, time::AbstractVector, site::AbstractVector, species::AbstractVector) -> DataFrame\n\nCalculates coefficients of variation (CV) for species and community biomass at both local and regional scales within a metacommunity.\n\nArguments\n\nabundance::AbstractVector: Vector representing the abundance of species.\ntime::AbstractVector: Vector representing sampling dates.\nsite::AbstractVector: Vector representing site names or IDs.\nspecies::AbstractVector: Vector representing species names or IDs.\n\nReturns\n\nDataFrame: A DataFrame containing the following columns:\nCV_s_l: Local-scale average species variability.\nCV_s_r: Regional-scale average species variability.\nCV_c_l: Local-scale average community variability.\nCV_c_r: Regional-scale community variability.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> CV_summary_df = CV_meta(df.Abundance, df.Sampling_date_order, df.plot, df.Species)\n1×4 DataFrame\n Row │ CV_s_l   CV_s_r    CV_c_l    CV_c_r   \n     │ Float64  Float64   Float64   Float64  \n─────┼───────────────────────────────────────\n   1 │ 1.48859  0.944937  0.718266  0.580183\n\n\n\n\n\n","category":"function"},{"location":"VariabilityMetrics/#References","page":"Variability Metrics Functions","title":"References","text":"","category":"section"},{"location":"VariabilityMetrics/","page":"Variability Metrics Functions","title":"Variability Metrics Functions","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290","category":"page"},{"location":"Acknowledgment/#Acknowledgment","page":"Acknowledgment","title":"Acknowledgment","text":"","category":"section"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package includes translations and adaptations of functions from the R packages adespatial (licensed under GPL-3), vegan (licensed under GPL-2 or later), DNCImper (licensed under GPL-3), and MVNH (licensed under GPL-3). The original packages and their documentation are available at:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"adespatial: https://cran.r-project.org/web/packages/adespatial/index.html\nvegan: https://cran.r-project.org/web/packages/vegan/index.html\nDNCImper: https://github.com/Corentin-Gibert-Paleontology/DNCImper\nMVNH : https://github.com/lvmuyang/MVNH","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"This package also includes translations and adaptations of functions that are provided by the scripts of these papers:","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Wang, S., Lamy, T., Hallett, L. M. & Loreau, M. Stability and synchrony across ecological hierarchies in heterogeneous metacommunities: linking theory to data. Ecography 42, 1200-1211 (2019). https://doi.org:https://doi.org/10.1111/ecog.04290\nGuzman, L. M. et al. Accounting for temporal change in multiple biodiversity patterns improves the inference of metacommunity processes. Ecology 103, e3683 (2022). https://doi.org:https://doi.org/10.1002/ecy.3683","category":"page"},{"location":"Acknowledgment/","page":"Acknowledgment","title":"Acknowledgment","text":"Please refer to these sources for full details on the original implementations and licenses.","category":"page"},{"location":"Benchmarking/#Benchmark-Results","page":"Benchmark Results","title":"Benchmark Results","text":"","category":"section"},{"location":"Benchmarking/#Computational-Resources","page":"Benchmark Results","title":"Computational Resources","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"All benchmarks were performed on the same machine to ensure consistent comparisons.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"CPU: Apple M4\nNumber of Cores: 10\nMemory: 16GB RAM\nOperating System: macOS Sequoia 15.6\nJulia Version: 1.10.10\nR Version: 4.4.2","category":"page"},{"location":"Benchmarking/#Benchmarking-Methods","page":"Benchmark Results","title":"Benchmarking Methods","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"To assess the efficiency of MetaCommunityMetrics compared to equivalent R implementations, we benchmark our functions against their R counterparts, focusing on execution time and memory usage. The following tables summarize the benchmark results based on 100 samples each. ","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"We tested using datasets of three sizes:","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Small (5,325 observations)\nMedium (26,676 observations) \nLarge (53,352 observations)","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"The large dataset is the sample data included with MetaCommunityMetrics, accessible via load_sample_data(). The small and medium datasets can be accessed here.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Each function was benchmarked using 100 samples in both BenchmarkTools.jl in Julia and bench::mark() in R to ensure robust statistical sampling. For memory usage comparisons:","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"In Julia, we report the memory estimate from BenchmarkTools.jl, which measures bytes allocated during the trial with minimum elapsed time\nIn R, we report the mem_alloc metric from bench::mark(), which tracks R heap allocations","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"According to documentation, the Julia metric measures total memory allocation during execution, while the R metric specifically tracks heap allocations within the R runtime, excluding \"memory allocated outside the R heap, e.g., by malloc() or new directly.\" Due to differences in language implementation and measurement methodology, direct numerical comparisons between languages should be interpreted with caution.","category":"page"},{"location":"Benchmarking/#Speedup-Summary","page":"Benchmark Results","title":"Speedup Summary","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Below is a plot showing the speedup of all benchmarked functions across the three datasets (small, medium and large). Speedup is calculated as the R median execution time divided by the Julia median execution time. (Image: Speedup Plot)","category":"page"},{"location":"Benchmarking/#Benchmark-Results-in-Details","page":"Benchmark Results","title":"Benchmark Results in Details","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"All times are in millisecond (ms), and memory is in mebibytes (MiB). All values are rounded up to 4 decimal places.","category":"page"},{"location":"Benchmarking/#Median-Execution-time-and-Speedup-Values","page":"Benchmark Results","title":"Median Execution time and Speedup Values","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"95% confidence interval is reported.","category":"page"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase DataSize Julia R Speedup Lower CI Upper CI\nBeta Diversity (Abundance, quant=true) Large 0.1244 2.1471 17.2602 16.6071 17.7147\nBeta Diversity (Abundance, quant=true) Medium 0.0778 1.3732 17.6518 17.3768 18.1861\nBeta Diversity (Abundance, quant=true) Small 0.0394 0.9179 23.3000 22.0561 25.3414\nBeta Diversity (Abundance, quant=false) Large 0.0146 0.1997 13.6934 13.2358 16.8835\nBeta Diversity (Abundance, quant=false) Medium 0.0104 0.2138 20.5226 19.6683 22.2222\nBeta Diversity (Abundance, quant=false) Small 0.0054 0.2414 44.5725 40.8472 47.8959\nBeta Diversity (Presence, quant=false) Large 0.0139 0.1962 14.1653 13.5828 14.7816\nBeta Diversity (Presence, quant=false) Medium 0.0113 0.1994 17.5968 17.1127 18.1192\nBeta Diversity (Presence, quant=false) Small 0.0057 0.2513 44.1863 39.5111 46.2503\nSpatial Beta Diversity (Abundance, quant=true) Large 2.1688 9.1234 4.2068 4.1387 4.3877\nSpatial Beta Diversity (Abundance, quant=true) Medium 1.4725 9.5022 6.4529 6.0358 6.5497\nSpatial Beta Diversity (Abundance, quant=true) Small 1.5839 9.4987 5.9971 5.7505 6.6586\nSpatial Beta Diversity (Abundance, quant=false) Large 1.9444 7.3179 3.7636 3.6124 3.8332\nSpatial Beta Diversity (Abundance, quant=false) Medium 1.6618 7.1957 4.3301 4.2245 4.4562\nSpatial Beta Diversity (Abundance, quant=false) Small 1.5207 6.9109 4.5447 4.3966 4.8593\nSpatial Beta Diversity (Presence, quant=false) Large 2.0419 8.0388 3.9370 3.8449 4.0554\nSpatial Beta Diversity (Presence, quant=false) Medium 1.7067 7.3284 4.2939 4.1892 4.4127\nSpatial Beta Diversity (Presence, quant=false) Small 1.4723 7.0079 4.7599 4.5737 5.1147\nTemporal Beta Diversity (Abundance, quant=true) Large 5.3096 53.9455 10.1600 10.0780 10.2358\nTemporal Beta Diversity (Abundance, quant=true) Medium 5.3015 53.3531 10.0638 9.8600 10.2946\nTemporal Beta Diversity (Abundance, quant=true) Small 4.7431 53.3732 11.2528 10.7984 11.5056\nTemporal Beta Diversity (Abundance, quant=false) Large 2.6548 9.5602 3.6012 3.5442 3.6613\nTemporal Beta Diversity (Abundance, quant=false) Medium 2.2395 9.4459 4.2179 4.0805 4.3567\nTemporal Beta Diversity (Abundance, quant=false) Small 2.2169 9.2761 4.1843 4.0034 4.3031\nTemporal Beta Diversity (Presence, quant=false) Large 2.6877 10.7795 4.0106 3.8444 4.1896\nTemporal Beta Diversity (Presence, quant=false) Medium 2.2363 9.7801 4.3734 4.2446 4.5393\nTemporal Beta Diversity (Presence, quant=false) Small 2.2682 9.2270 4.0680 3.9668 4.3038\nDispersal-niche continuum index Large 588.7658 12574.8461 21.3580 21.2157 21.4509\nDispersal-niche continuum index Medium 505.2023 12268.2182 24.2838 24.1870 24.3857\nDispersal-niche continuum index Small 122.3677 3140.2943 25.6628 25.4323 25.8697\nOccupied Patches Proportion Large 0.8469 7.2455 8.5554 8.2737 8.8168\nOccupied Patches Proportion Medium 0.6504 7.3115 11.2416 10.8683 11.8014\nOccupied Patches Proportion Small 0.3657 7.0934 19.3974 18.6676 20.1553\nVariability Metrics Large 13.8979 98.9990 7.1233 7.0156 7.1537\nVariability Metrics Medium 7.9131 52.7903 6.6713 6.6224 6.7430\nVariability Metrics Small 2.7518 14.2607 5.1824 5.1289 5.2272\nHypervolume Estimation Large 0.0035 0.0328 9.3831 8.4226 18.6374\nHypervolume Estimation Medium 0.0032 0.0276 8.7127 8.5896 8.8098\nHypervolume Estimation Small 0.0029 0.0264 9.2643 9.0658 9.4181\nHypervolume Dissimilarity Large 0.0064 0.1147 17.9885 17.6258 18.2162\nHypervolume Dissimilarity Medium 0.0056 0.1188 21.3605 21.1646 21.6136\nHypervolume Dissimilarity Small 0.0050 0.1852 37.3449 34.6406 38.0277","category":"page"},{"location":"Benchmarking/#Memory-Usage","page":"Benchmark Results","title":"Memory Usage","text":"","category":"section"},{"location":"Benchmarking/#Benchmarked-using-Large-Dataset","page":"Benchmark Results","title":"Benchmarked using Large Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.4346 0.0566\nBeta Diversity (Abundance, quant=false) 0.1347 0.1252\nBeta Diversity (Presence, quant=false) 0.1347 0.1252\nSpatial Beta Diversity (Abundance, quant=true) 3.9185 3.1142\nSpatial Beta Diversity (Abundance, quant=false) 3.5173 2.6712\nSpatial Beta Diversity (Presence, quant=false) 3.5173 2.6712\nTemporal Beta Diversity (Abundance, quant=true) 16.8838 16.8863\nTemporal Beta Diversity (Abundance, quant=false) 5.6586 5.1752\nTemporal Beta Diversity (Presence, quant=false) 5.6586 5.1752\nDispersal-niche continuum index 781.9220 71.9833\nOccupied Patches Proportion 1.9098 1.8857\nVariability Metrics 12.4573 60.2217\nHypervolume Estimation 0.0122 0.0022\nHypervolume Dissimilarity 0.0168 0.0145","category":"page"},{"location":"Benchmarking/#Benchmarked-using-Medium-Dataset","page":"Benchmark Results","title":"Benchmarked using Medium Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.2491 0.0357\nBeta Diversity (Abundance, quant=false) 0.1086 0.0798\nBeta Diversity (Presence, quant=false) 0.1086 0.0798\nSpatial Beta Diversity (Abundance, quant=true) 2.3901 2.2736\nSpatial Beta Diversity (Abundance, quant=false) 1.9915 1.8306\nSpatial Beta Diversity (Presence, quant=false) 1.9915 1.8306\nTemporal Beta Diversity (Abundance, quant=true) 15.2773 16.2509\nTemporal Beta Diversity (Abundance, quant=false) 4.1328 4.5397\nTemporal Beta Diversity (Presence, quant=false) 4.1328 4.5397\nDispersal-niche continuum index 542.9327 59.2854\nOccupied Patches Proportion 0.9940 1.3994\nVariability Metrics 7.6746 32.5536\nHypervolume Estimation 0.0085 0.0011\nHypervolume Dissimilarity 0.0120 0.0077","category":"page"},{"location":"Benchmarking/#Benchmarked-using-Small-Dataset","page":"Benchmark Results","title":"Benchmarked using Small Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"TestCase Julia R\nBeta Diversity (Abundance, quant=true) 0.1225 0.0195\nBeta Diversity (Abundance, quant=false) 0.0883 0.0444\nBeta Diversity (Presence, quant=false) 0.0883 0.0444\nSpatial Beta Diversity (Abundance, quant=true) 1.1334 1.2126\nSpatial Beta Diversity (Abundance, quant=false) 0.7663 0.7696\nSpatial Beta Diversity (Presence, quant=false) 0.7663 0.7696\nTemporal Beta Diversity (Abundance, quant=true) 12.8811 15.4341\nTemporal Beta Diversity (Abundance, quant=false) 2.8937 3.7230\nTemporal Beta Diversity (Presence, quant=false) 2.8937 3.7230\nDispersal-niche continuum index 192.5782 11.1101\nOccupied Patches Proportion 0.2612 0.4931\nVariability Metrics 3.8483 10.5805\nHypervolume Estimation 0.0059 0.0003\nHypervolume Dissimilarity 0.0082 0.0014","category":"page"},{"location":"Benchmarking/#Datesets-used-for-this-benchmark","page":"Benchmark Results","title":"Datesets used for this benchmark","text":"","category":"section"},{"location":"Benchmarking/#Large-Dataset","page":"Benchmark Results","title":"Large Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted","category":"page"},{"location":"Benchmarking/#Medium-Dataset","page":"Benchmark Results","title":"Medium Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"26676×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2015      7     18                   56     12  PM               0         0      35.5     -107.5              -1.30965                  0.967859\n     2 │  2016      8      6                   66     13  SF               0         0      36.0     -110.0               1.45692                  1.77253\n     3 │  2017      2     25                   71     21  SF               0         0      36.5     -109.0              -1.50086                  0.993311\n     4 │  2018      5     19                   82     16  PB               0         0      36.0     -108.5              -1.2202                   0.684295\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 26673 │  2010     11      6                    8     13  BA               0         0      36.0     -110.0              -1.05336                 -0.250324\n 26674 │  2013      9     14                   36     12  NA               0         0      35.5     -107.5               0.213222                 0.12\n 26675 │  2023      2     18                  116     12  DS               0         0      35.5     -107.5              -0.217475                 0.042571\n 26676 │  2014     11     22                   49     13  PF               0         0      36.0     -110.0               0.613491                -1.17076\n                                                                                                                                            26668 rows omitted","category":"page"},{"location":"Benchmarking/#Small-Dataset","page":"Benchmark Results","title":"Small Dataset","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"5335×12 DataFrame\n  Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n      │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n──────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │  2015      7     18                   56     12  PM               0         0      35.5     -107.5               -1.30965                 0.967859\n    2 │  2016      8      6                   66     13  SF               0         0      36.0     -110.0                1.45692                 1.77253\n    3 │  2017      2     25                   71     21  SF               0         0      36.5     -109.0               -1.50086                 0.993311\n    4 │  2018      5     19                   82     16  PB               0         0      36.0     -108.5               -1.2202                  0.684295\n  ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 5332 │  2013     11      2                   37     13  RF               0         0      36.0     -110.0                2.07639                 2.72841\n 5333 │  2018     11     10                   88      6  PH               0         0      35.0     -107.5               -0.197006                0.842547\n 5334 │  2018      3     24                   80      2  DS               0         0      35.0     -109.5               -0.920093               -0.276074\n 5335 │  2014      4     26                   42      7  PH               0         0      35.5     -110.0                0.848755               -0.247144\n                                                                                                                                            5327 rows omitted","category":"page"},{"location":"Benchmarking/#Remarks","page":"Benchmark Results","title":"Remarks","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"For DNCI_multigroup_result, 100 permutations are used in both the Julia and R implementation, and parallelComputing was set to be TRUE when benchmarking DNCImper:::DNCI_multigroup() in R.","category":"page"},{"location":"Benchmarking/#The-Scripts-Used-for-Benchmarking","page":"Benchmark Results","title":"The Scripts Used for Benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"Julia\nR","category":"page"},{"location":"Benchmarking/#Packages-used-for-benchmarking","page":"Benchmark Results","title":"Packages used for benchmarking","text":"","category":"section"},{"location":"Benchmarking/","page":"Benchmark Results","title":"Benchmark Results","text":"bench\nBenchmarkTools.jl","category":"page"},{"location":"DNCI/#Dispersal-Niche-Continuum-Index-(DNCI)-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The Dispersal-Niche Continuum Index (DNCI) functions in MetaCommunityMetrics quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. The function DNCI_multigroup  in this package is adapted from the R package DNCImper: Assembly process identification based on SIMPER analysis. These methods, originally developed by Clarke(1993) and later refined by Gibert & Escarguel(2019) and Vilmi et al.(2021), offer powerful tools for identifying the processes underlying species assembly in metacommunities. ","category":"page"},{"location":"DNCI/#Background","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Background","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions is built around the Per-SIMPER and DNCI analyses. PerSIMPER, based on the Similarity Percentage (SIMPER) analysis developed by Clarke (1993), assesses the contribution of individual taxa to overall dissimilarity (OAD) between groups of assemblages. PerSIMPER enhances this by comparing empirical SIMPER plots with randomized plots generated through matrix permutation, which helps identify whether niche, dispersal, or both processes are driving community assembly.","category":"page"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI (Dispersal-Niche Continuum Index) further extends this approach by transforming the qualitative results of PerSIMPER into a quantitative index, providing a straightforward measure of the influence of niche and dispersal processes on community structure.","category":"page"},{"location":"DNCI/#Functionality-Overview","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Functionality Overview","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"The DNCI functions in MetaCommunityMetrics allow you to analyze the processes driving species assembly within your dataset. By comparing empirical data with randomized permutations, one can determine the extent to which niche and dispersal processes influence the structure of metacommunities. Before calculating the DNCI, groupings of sites (clusters) are required, as the DNCI relies on analyzing community composition across spatial groups. This package provides a function to perform the necessary clustering, which is not available in the equivalent R package. When the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. In contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. If the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to variations in community composition.","category":"page"},{"location":"DNCI/#The-Functions","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"The Functions","text":"","category":"section"},{"location":"DNCI/#MetaCommunityMetrics.create_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.create_clusters","text":"create_clusters(time::AbstractVector, latitude::Vector{Float64}, longitude::Vector{Float64}, site::AbstractVector, species::AbstractVector, presence::AbstractVector) -> Dict{Int, DataFrame}\n\nThis function creates clusters (groupings of sites) for each unique time step in a dataset which can then used for calculating DNCI. Only presnece-absence data can be used.\n\nArguments\n\ntime::AbstractVector: Vector or single value representing sampling dates. Can be strings, integers, or any other type.\nlatitude::Vector: A vector indicating the latitude of each site.\nlongitude::Vector: A vector indicating the longitude of each site.\nsite::AbstractVector: A vector indicating the spatial location of each site. At least 10 sites are required for clustering.\nspecies::AbstractVector: A vector indicating the species present at each site.\npresence::AbstractVector: A vector indicating the presence (1) or absence (0) of species at each site.\n\nReturns\n\nDict{Int, DataFrame}: A dictionary where each key represents a unique time point from the input data, with the corresponding value being a DataFrame for that time step. Each DataFrame contains the following columns: Time, Latitude, Longitude, Site, Species, Presence and Group (indicating the assigned cluster).\n\nDetails\n\nThis function performs hierarchical clustering on the geographical coordinates of sampling sites at each unique time step. \nThis function incorporates checks and adjustments to ensure the following conditions are met: at least 2 clusters, a minimum of 5 sites per cluster, and that the variation in the number of taxa/species and sites per group does not exceed 40% and 30%, respectively. These conditions are critical for calculating an unbiased DNCI value, and the function will issue warnings and the groupings will be returned as \"missing\" if any are not fulfilled.\nEmpty sites are allowed.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> clustering_result = create_clusters(df.Sampling_date_order, df.Latitude, df.Longitude, df.plot, df.Species, df.Presence)\nWarning: Cluster count fell below 2 at time 10, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 14, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 76, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 89, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 99, which is not permissible for clustering. Groups assigned as missing.\nDict{Int64, DataFrames.DataFrame} with 117 entries:\n  5   => 456×7 DataFrame…\n  56  => 456×7 DataFrame…\n  35  => 456×7 DataFrame…\n  55  => 456×7 DataFrame…\n  110 => 456×7 DataFrame…\n  114 => 456×7 DataFrame…\n  60  => 456×7 DataFrame…\n  30  => 456×7 DataFrame…\n  32  => 456×7 DataFrame…\n  6   => 456×7 DataFrame…\n  67  => 456×7 DataFrame…\n  45  => 456×7 DataFrame…\n  117 => 456×7 DataFrame…\n  73  => 456×7 DataFrame…\n  ⋮   => ⋮\n\njulia> clustering_result[10]      \n456×7 DataFrame\n Row │ Time   Latitude  Longitude  Site   Species  Presence  Group   \n     │ Int64  Float64   Float64    Int64  String3  Int64     Missing \n─────┼───────────────────────────────────────────────────────────────\n   1 │    10      35.0     -110.0      1  BA              0  missing \n   2 │    10      35.0     -109.5      2  BA              0  missing \n   3 │    10      35.0     -108.5      4  BA              0  missing \n   4 │    10      35.5     -109.5      8  BA              0  missing \n   5 │    10      35.5     -109.0      9  BA              0  missing \n  ⋮  │   ⋮       ⋮          ⋮        ⋮       ⋮        ⋮         ⋮\n 452 │    10      35.5     -110.0      7  SH              0  missing \n 453 │    10      35.5     -108.5     10  SH              0  missing \n 454 │    10      36.0     -108.5     16  SH              0  missing \n 455 │    10      36.5     -108.0     23  SH              0  missing \n 456 │    10      36.5     -107.5     24  SH              0  missing \n                                                     446 rows omitted      \n \njulia> clustering_result[60]                                                      \n456×7 DataFrame\n Row │ Time   Latitude  Longitude  Site   Species  Presence  Group  \n     │ Int64  Float64   Float64    Int64  String3  Int64     Int64? \n─────┼──────────────────────────────────────────────────────────────\n   1 │    60      35.0     -108.5      4  BA              0       1\n   2 │    60      35.0     -108.0      5  BA              1       1\n   3 │    60      35.0     -107.5      6  BA              0       1\n   4 │    60      35.5     -110.0      7  BA              0       2\n   5 │    60      35.5     -108.0     11  BA              0       1\n  ⋮  │   ⋮       ⋮          ⋮        ⋮       ⋮        ⋮        ⋮\n 452 │    60      35.5     -109.0      9  SH              0       2\n 453 │    60      35.5     -108.5     10  SH              0       1\n 454 │    60      35.5     -107.5     12  SH              1       1\n 455 │    60      36.0     -108.5     16  SH              0       4\n 456 │    60      36.5     -108.0     23  SH              0       4\n                                                    446 rows omitted\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#MetaCommunityMetrics.plot_clusters","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.plot_clusters","text":"plot_clusters(latitude::Vector{Float64}, longitude::Vector{Float64}, group::AbstractVector, output_file=\"clusters.svg\") -> String\n\nVisualizes clustering results by generating an SVG image displaying the geographic coordinates and cluster assignments of sampling sites.\n\nArguments\n\nlatitude::Vector{Float64}: A vector of latitude coordinates of the sampling sites.\nlongitude::Vector{Float64}: A vector of longitude coordinates of the sampling sites.\ngroup::AbstractVector: A vector indicating the group assignments for each data point.\noutput_file::String=\"clusters.svg\": The filename for the output SVG visualization. Default is \"clusters.svg\".\n\nReturns\n\nString: The path to the created SVG file.\n\nDetails\n\nThe function generates a standalone SVG file that can be viewed in any web browser or image viewer.\nEach cluster is assigned a unique color, and sampling sites are plotted based on their geographic coordinates.\nThe visualization includes a legend identifying each cluster.\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> clustering_result = create_clusters(df.Sampling_date_order, df.Latitude, df.Longitude, df.plot, df.Species, df.Presence)\nWarning: Cluster count fell below 2 at time 10, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 14, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 76, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 89, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 99, which is not permissible for clustering. Groups assigned as missing.\nDict{Int64, DataFrames.DataFrame} with 117 entries:\n  5   => 456×7 DataFrame…\n  56  => 456×7 DataFrame…\n  35  => 456×7 DataFrame…\n  55  => 456×7 DataFrame…\n  110 => 456×7 DataFrame…\n  114 => 456×7 DataFrame…\n  60  => 456×7 DataFrame…\n  30  => 456×7 DataFrame…\n  32  => 456×7 DataFrame…\n  6   => 456×7 DataFrame…\n  67  => 456×7 DataFrame…\n  45  => 456×7 DataFrame…\n  117 => 456×7 DataFrame…\n  73  => 456×7 DataFrame…\n  ⋮   => ⋮\n\njulia> clustering_result[60]                                                      \n456×7 DataFrame\n Row │ Time   Latitude  Longitude  Site   Species  Presence  Group  \n     │ Int64  Float64   Float64    Int64  String3  Int64     Int64? \n─────┼──────────────────────────────────────────────────────────────\n   1 │    60      35.0     -108.5      4  BA              0       1\n   2 │    60      35.0     -108.0      5  BA              1       1\n   3 │    60      35.0     -107.5      6  BA              0       1\n   4 │    60      35.5     -110.0      7  BA              0       2\n   5 │    60      35.5     -108.0     11  BA              0       1\n  ⋮  │   ⋮       ⋮          ⋮        ⋮       ⋮        ⋮        ⋮\n 452 │    60      35.5     -109.0      9  SH              0       2\n 453 │    60      35.5     -108.5     10  SH              0       1\n 454 │    60      35.5     -107.5     12  SH              1       1\n 455 │    60      36.0     -108.5     16  SH              0       4\n 456 │    60      36.5     -108.0     23  SH              0       4\n                                                    446 rows omitted\n\njulia> plot_clusters(clustering_result[60].Latitude, clustering_result[60].Longitude, clustering_result[60].Group; output_file=\"clusters.svg\")\n\n\n\n\n\n\n","category":"function"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"This plot shows the clustering result for time step 1 based on geographic coordinates: (Image: Cluster Plot)","category":"page"},{"location":"DNCI/#MetaCommunityMetrics.DNCI_multigroup","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"MetaCommunityMetrics.DNCI_multigroup","text":"DNCI_multigroup(comm::Matrix, groups::Vector, Nperm::Int=1000; Nperm_count::Bool=true) -> DataFrame\n\nCalculates the dispersal-niche continuum index (DNCI) for multiple groups, a metric proposed by Vilmi(2021). The DNCI quantifies the balance between dispersal and niche processes within a metacommunity, providing insight into community structure and the relative influence of these two key ecological drivers. \n\nArguments\n\ncomm::Matrix: A presence-absence data matrix where rows represent observations (e.g., sites or samples) and columns represent species.\ngroups::Vector: A vector indicating the group membership for each row in the comm matrix. You can use the create_clusters function to generate the group membership.\nNperm::Int=1000: The number of permutations for significance testing. Default is 1000.\nNperm_count::Bool=true: A flag indicating whether the number of permutations is printed. Default is false.\n\nReturns\n\nThe DataFrame will have the following columns:\nGroup1: The first group in the pair.\nGroup2: The second group in the pair.\nDNCI: The calculated DNCI value.\nCI_DNCI: The confidence interval for the DNCI value.\nS_DNCI: The standard deviation of the DNCI value.\nStatus: A string indicating how the DNCI is calculated. It is mainly used to flag edge cases as follows:     - normal indicates that the DNCI is calculated as normal.     - empty_community indicates no species existed in any sites in a given group pair, DNCI, CI_DNCI, and S_DNCI are returned as NaN.     - only_one_species_exists indicates that only one species existed in a given group pair, which is not possible to calculate relative species contribution to overall dissimilarity. DNCI, CI_DNCI, and S_DNCI are returned as NaN.     - quasi_swap_permutation_not_possible indicates that the quasi-swap permutation (a matrix permutation algorithms that preserves row and column sums) is not possible due to extreme matrix constraints that prevent any rearrangement of species across sites. DNCI, CIDNCI, and SDNCI are returned as NaN.     - one_way_to_quasi_swap indicates that only one arrangement is possible under quasi-swap constraints, preventing generation of a null distribution. DNCI, CIDNCI, and SDNCI are returned as NaN.     - inadequate_variation_quasi_swap indicates that quasi-swap permutations generated insufficient variation (coefficient of variation <1%) for reliable statistical inference. DNCI, CIDNCI, and SDNCI are returned as NaN.\n\nDetails\n\nThe function calculates the DNCI for each pair of groups in the input data.\nWhen the DNCI value is significantly below zero, dispersal processes are likely the dominant drivers of community composition. \nIn contrast, a DNCI value significantly above zero suggests that niche processes play a primary role in shaping community composition. \nIf the DNCI value is not significantly different from zero, it indicates that dispersal and niche processes contribute equally to spatial variations in community composition at a given time point.\nDifferent from the original implementation, empty sites and singletons (species that only occupy one site at a given time) are allowed.\nThis function is a adaptation of the function DNCI_multigroup() from the R package DNCImper, licensed under GPL-3.\nOriginal package and documentation available at: https://github.com/Corentin-Gibert-Paleontology/DNCImper\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Random\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n                                                                                          \njulia> clustering_result = create_clusters(df.Sampling_date_order, df.Latitude, df.Longitude, df.plot, df.Species, df.Presence)\nWarning: Cluster count fell below 2 at time 10, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 14, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 76, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 89, which is not permissible for clustering. Groups assigned as missing.\nWarning: Cluster count fell below 2 at time 99, which is not permissible for clustering. Groups assigned as missing.\nDict{Int64, DataFrames.DataFrame} with 117 entries:\n  5   => 456×7 DataFrame…\n  56  => 456×7 DataFrame…\n  35  => 456×7 DataFrame…\n  55  => 456×7 DataFrame…\n  110 => 456×7 DataFrame…\n  114 => 456×7 DataFrame…\n  60  => 456×7 DataFrame…\n  30  => 456×7 DataFrame…\n  32  => 456×7 DataFrame…\n  6   => 456×7 DataFrame…\n  67  => 456×7 DataFrame…\n  45  => 456×7 DataFrame…\n  117 => 456×7 DataFrame…\n  73  => 456×7 DataFrame…\n  ⋮   => ⋮\n\njulia> clustering_result[60]\n456×7 DataFrame\n Row │ Time   Latitude  Longitude  Site   Species  Presence  Group  \n     │ Int64  Float64   Float64    Int64  String3  Int64     Int64? \n─────┼──────────────────────────────────────────────────────────────\n   1 │    60      35.0     -108.5      4  BA              0       1\n   2 │    60      35.0     -108.0      5  BA              1       1\n   3 │    60      35.0     -107.5      6  BA              0       1\n   4 │    60      35.5     -110.0      7  BA              0       2\n   5 │    60      35.5     -108.0     11  BA              0       1\n  ⋮  │   ⋮       ⋮          ⋮        ⋮       ⋮        ⋮        ⋮\n 452 │    60      35.5     -109.0      9  SH              0       2\n 453 │    60      35.5     -108.5     10  SH              0       1\n 454 │    60      35.5     -107.5     12  SH              1       1\n 455 │    60      36.0     -108.5     16  SH              0       4\n 456 │    60      36.5     -108.0     23  SH              0       4\n                                                    446 rows omitted\n\njulia> group_df = @pipe df |>\n                filter(row -> row[:Sampling_date_order] == 60, _) |>\n                select(_, [:plot, :Species, :Presence]) |>\n                innerjoin(_, clustering_result[60], on = [:plot => :Site, :Species], makeunique = true)|>\n                select(_, [:plot, :Species, :Presence, :Group]) |>\n                unstack(_, :Species, :Presence, fill=0)\n24×21 DataFrame\n Row │ plot   Group   BA     DM     DO     DS     NA     OL     OT     PB     PE     PF     PH     PL     PM     PP     RF     RM     RO     SF     SH    \n     │ Int64  Int64?  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64 \n─────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │     4       1      0      1      1      0      0      1      1      0      0      0      0      0      0      0      0      1      0      1      0\n   2 │     5       1      1      1      1      0      0      0      1      0      1      0      0      0      0      1      0      1      0      0      0\n   3 │     6       1      0      1      1      0      0      0      0      0      1      0      0      0      0      1      0      1      0      0      0\n   4 │     7       2      0      1      1      0      0      1      1      0      0      0      0      0      0      1      0      0      0      0      1\n   5 │    11       1      0      1      1      0      0      0      1      0      0      0      0      0      0      1      0      0      0      0      0\n  ⋮  │   ⋮      ⋮       ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n  20 │     9       2      0      1      0      0      0      1      1      0      1      0      0      0      0      0      0      0      0      0      0\n  21 │    10       1      0      0      0      0      0      0      0      0      1      0      0      0      0      1      0      0      0      0      0\n  22 │    12       1      0      0      0      0      1      0      1      0      1      0      0      0      1      0      0      1      0      0      1\n  23 │    16       4      0      0      1      0      0      0      1      0      1      0      0      0      0      0      0      1      0      0      0\n  24 │    23       4      0      1      0      0      0      0      0      1      0      0      0      0      1      0      0      0      0      0      0\n                                                                                                                                           14 rows omitted\n                                                                                                                                          \njulia> comm= @pipe group_df |>\n                  select(_, Not([:plot,:Group])) |>\n                  Matrix(_)\n24×19 Matrix{Int64}:\n 0  1  1  0  0  1  1  0  0  0  0  0  0  0  0  1  0  1  0\n 1  1  1  0  0  0  1  0  1  0  0  0  0  1  0  1  0  0  0\n 0  1  1  0  0  0  0  0  1  0  0  0  0  1  0  1  0  0  0\n 0  1  1  0  0  1  1  0  0  0  0  0  0  1  0  0  0  0  1\n 0  1  1  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0\n 0  1  1  0  0  0  0  1  1  0  0  0  0  0  0  1  0  0  0\n 1  1  1  0  0  0  0  0  0  0  0  0  0  1  0  1  0  0  0\n ⋮              ⋮              ⋮              ⋮        \n 0  0  0  0  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  1  0  1  0  0  1  1  0  0  0  0  0  0\n 0  1  0  0  0  1  1  0  1  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0\n 0  0  0  0  1  0  1  0  1  0  0  0  1  0  0  1  0  0  1\n 0  0  1  0  0  0  1  0  1  0  0  0  0  0  0  1  0  0  0\n 0  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0  0\n\njulia> Random.seed!(1234) \n\njulia> DNCI_result = DNCI_multigroup(comm, group_df.Group, 1000; Nperm_count = false)\n6×6 DataFrame\n Row │ group1  group2  DNCI      CI_DNCI  S_DNCI    status \n     │ Int64   Int64   Float64   Float64  Float64   String \n─────┼─────────────────────────────────────────────────────\n   1 │      1       2  -3.41127  2.17348  1.08674   normal\n   2 │      1       3  -2.44866  2.05951  1.02976   normal\n   3 │      1       4  -2.3671   2.45697  1.22848   normal\n   4 │      2       3  -2.65022  2.28931  1.14466   normal\n   5 │      2       4  -3.0168   2.43496  1.21748   normal\n   6 │      3       4  -1.83521  1.9589   0.979449  normal\n\n\n\n\n\n","category":"function"},{"location":"DNCI/#References","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"References","text":"","category":"section"},{"location":"DNCI/","page":"Dispersal-Niche Continuum Index (DNCI) Functions","title":"Dispersal-Niche Continuum Index (DNCI) Functions","text":"Clarke, K. R. Non-parametric multivariate analyses of changes in community structure. Australian Journal of Ecology 18, 117-143 (1993). https://doi.org:https://doi.org/10.1111/j.1442-9993.1993.tb00438.x\nGibert, C. & Escarguel, G. PER-SIMPER—A new tool for inferring community assembly processes from taxon occurrences. Global Ecology and Biogeography 28, 374-385 (2019). https://doi.org:https://doi.org/10.1111/geb.12859\nVilmi, A. et al. Dispersal–niche continuum index: a new quantitative metric for assessing the relative importance of dispersal versus niche processes in community assembly. Ecography 44, 370-379 (2021). https://doi.org:https://doi.org/10.1111/ecog.05356","category":"page"},{"location":"Hypervolume/#Hypervolume-Functions","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Hypervolume is a method originally proposed by Hutchinson (1957). It provide methods to calculate the volume of a niche for a given specice and thus the ncihe overlap between two species. It helps to infer how niche breath of species has contribute to the co-occurance of different species in the same location at the same time. The hypervolume functions provide by this package are adapted from the R package MVNH (https://github.com/lvmuyang/MVNH).","category":"page"},{"location":"Hypervolume/#An-Overview","page":"Hypervolume Functions","title":"An Overview","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The MVNH framework provides parametric measures for analyzing ecological niches using the multivariate normal distribution model. This framework offers powerful tools for quantifying and comparing the size and dissimilarity of species' niches, with each measure being partitionable into biologically meaningful components.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"The framework models a species' niche as a multivariate normal distribution in environmental space, where:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Each environmental variable represents one dimension of the niche.\nThe mean vector represents the niche optimum.\nThe covariance matrix represents the niche breadth and shape.","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"There are four hypervolume functions in this package:","category":"page"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"MVNH_det calculates the total hypervolume of a species' niche based on the determinant of the covariance matrix (generalized variance). This measure can be partitioned into:\nMVNH_dissimilarity calculates the Bhattacharyya distance between two species' niches, providing a comprehensive measure of niche differentiation. \naverage_MVNH_det calculates the mean hypervolume across multiple species in a community, providing an overall measure of niche size at the community level.\naverage_MVNH_dissimilarity calculates the mean Bhattacharyya distance between all unique pairs of species in a community, providing a measure of overall niche differentiation.","category":"page"},{"location":"Hypervolume/#Practical-Considerations","page":"Hypervolume Functions","title":"Practical Considerations","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Statistical assumptions: This framework relies on multivariate normal distribution of environmental data.\nWhen encountering skewed variables, apply appropriate transformations to achieve approximately normal distributions\nBe aware that as you increase the number of variables, you face greater challenges with:\nVariable interdependence (collinearity) which can drive determinant values toward zero\nPotential violations of the multivariate normality assumption\nAddress variable interdependence through either:\nThoughtful pre-selection of ecologically meaningful variables with direct influence on species distributions\nApplication of dimension reduction methods such as PCA (principal component analysis)\nImportant note: PCA creates orthogonal axes, which forces the correlation component to 1.0, eliminating correlation structure information.\nFor datasets containing multiple distinct groups of related environmental variables (such as climate factors, soil properties, or topographic features), consider using generalized canonical variables to identify the most representative variables within each natural category while preserving the ecological relationships between different variable groups.\nMeasurement standardization: Before analysis, standardize all environmental variables to comparable scales to prevent variables with larger numerical ranges from disproportionately influencing results.","category":"page"},{"location":"Hypervolume/#The-Functions","page":"Hypervolume Functions","title":"The Functions","text":"","category":"section"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_det","text":"MVNH_det(data::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate the niche hypervolume of a species based on environmental variables.\n\nArguments\n\ndata::DataFrame: DataFrame where each row represents an observation of a species (presence only, need to filter out absences) and columns represent environmental variables.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A DataFrame containing:\nCorrelation: The correlation component (calculated as det(COV)/prod(variances))\nOne column for each environmental variable showing its variance\ntotal: The total hypervolume (calculated as the determinant of the covariance matrix)\n\nDetails\n\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be standardized before using this function to avoid bias from different scales\nThe function computes the covariance matrix of the input data, extracts variances, and calculates the determinant\nThis function is a Julia implementation of the MVNH_det function from the R package MVNH (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics, UnicodePlots\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:standardized_temperature, :standardized_precipitation])\n143×2 DataFrame\n Row │ standardized_temperature  standardized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> result = MVNH_det(data; var_names=[\"Temperature\", \"Precipitation\"])\n1×4 DataFrame\n Row │ total    correlation  Temperature  Precipitation \n     │ Float64  Float64      Float64      Float64       \n─────┼──────────────────────────────────────────────────\n   1 │ 1.15268     0.999732     0.962495        1.19792\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.MVNH_dissimilarity","text":"MVNH_dissimilarity(data_1::DataFrame, data_2::DataFrame; var_names::Vector{String}=String[]) -> DataFrame\n\nCalculate niche dissimilarity between two species based on their environmental variables, using the Bhattacharyya distance and its components.\n\nArguments\n\ndata_1::DataFrame: DataFrame for the first species, where each row represents an observation (presence only, need to filter out absences) and columns represent environmental variables.\ndata_2::DataFrame: DataFrame for the second species, with the same structure as data_1.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names \"variable1\", \"variable2\", etc. will be used.\n\nReturns\n\nDataFrame: A dataframe containing three metrics and their components:\n\"Bhattacharyya_distance\": The total Bhattacharyya distance and its components\n\"Mahalanobis_distance\": The Mahalanobis component of the Bhattacharyya distance\n\"Determinant_ratio\": The determinant ratio component of the Bhattacharyya distance\nEach metric contains:\ntotal: The total value of the respective distance measure\ncorrelation: The correlation component of the distance measure\nOne value for each environmental variable showing its contribution to the distance\n\nDetails\n\nThe Bhattacharyya distance is calculated as the sum of two components:\nMahalanobis component: (1/8) × (μ₁-μ₂)ᵀ × (S₁+S₂)/2⁻¹ × (μ₁-μ₂)\nDeterminant ratio component: (1/2) × log(det((S₁+S₂)/2) / sqrt(det(S₁) × det(S₂)))\nEach component is further decomposed into individual variable contributions and correlation effects\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be standardized_ before using this function to avoid bias from different scales\nThis function is a Julia implementation inspired by the MVNH R package (GPL-3)\nOriginal package and documentation: https://github.com/lvmuyang/MVNH\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = load_sample_data()\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\n\njulia> data_1 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"BA\", _) |>\n            select(_, [:standardized_temperature, :standardized_precipitation])\n\n143×2 DataFrame\n Row │ standardized_temperature  standardized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │            -0.37813                    0.13009\n   2 │            -0.00856861                 0.237183\n   3 │            -0.664638                  -0.772406\n   4 │             2.05431                    0.451875\n   5 │            -0.39968                   -0.719024\n  ⋮  │           ⋮                        ⋮\n 139 │             1.85574                   -0.583737\n 140 │             0.0953878                  1.21099\n 141 │            -1.02227                    1.33501\n 142 │            -0.400246                  -0.438892\n 143 │            -0.817817                   0.418038\n                                        133 rows omitted\n\njulia> data_2 = @pipe df |> \n            filter(row -> row[:Presence] > 0, _) |>\n            filter(row -> row[:Species] == \"SH\", _) |>\n            select(_, [:standardized_temperature, :standardized_precipitation])\n58×2 DataFrame\n Row │ standardized_temperature  standardized_precipitation \n     │ Float64                 Float64                  \n─────┼──────────────────────────────────────────────────\n   1 │              -0.229864                  1.84371\n   2 │               0.460218                 -0.624328\n   3 │              -1.03283                  -1.16451\n   4 │               0.675006                 -0.120586\n   5 │               0.40729                   0.20034\n  ⋮  │           ⋮                        ⋮\n  54 │              -0.870299                 -0.235392\n  55 │               0.504555                 -1.50887\n  56 │               2.03065                  -0.740789\n  57 │              -0.174396                  0.448461\n  58 │               0.547169                  1.03257\n                                         48 rows omitted\n                   \njulia> result = MVNH_dissimilarity(data_1, data_2; var_names=[\"Temperature\", \"Precipitation\"])\n3×5 DataFrame\n Row │ metric                  total       correlation  Temperature  Precipitation \n     │ String                  Float64     Float64      Float64      Float64       \n─────┼─────────────────────────────────────────────────────────────────────────────\n   1 │ Bhattacharyya_distance  0.00980771  0.00015205    0.00388058     0.00577508\n   2 │ Mahalanobis_distance    0.00664862  5.06232e-6    0.00234902     0.00429454\n   3 │ Determinant_ratio       0.00315908  0.000146988   0.00153156     0.00148054\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_det","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_det","text":"average_MVNH_det(data::DataFrame, presence_absence::Vector{Int}, species::AbstractVector; \n                 var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche hypervolume across multiple species in a community dataset.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::AbstractVector: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average hypervolume across all species with presence data.\n\nDetails\n\nFor each unique species, the function:\nFilters observations where the species is present (presence_absence > 0)\nCalculates the niche hypervolume using the MVNH_det function\nExtracts the total hypervolume value\nThe function then computes the mean of all individual species hypervolumes\nSpecies with no presence data are skipped in the calculation\nEnvironmental variables are assumed to follow a multivariate normal distribution, otherwise transformation to normal distribution is recommended before using this function.\nVariables should be standardized before using this function to avoid bias from different scales\nSingletons should be removed before using this function to avoid NaN values in the hypervolume calculation\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = @pipe load_sample_data() |>\n                      groupby(_, :Species) |>\n                      filter(row -> sum(row.Presence) > 1, _)|>\n                      DataFrame(_)\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:standardized_temperature, :standardized_precipitation]) \n53352×2 DataFrame\n   Row │ standardized_temperature  standardized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_det(data, df.Presence, df.Species; var_names=[\"Temperature\", \"Precipitation\"])\n1.2103765096417536\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#MetaCommunityMetrics.average_MVNH_dissimilarity","page":"Hypervolume Functions","title":"MetaCommunityMetrics.average_MVNH_dissimilarity","text":"average_MVNH_dissimilarity(data::DataFrame, presence_absence::Vector{Int}, species::AbstractVector; \n                          var_names::Vector{String}=String[]) -> Float64\n\nCalculate the average niche dissimilarity between all unique pairs of species in a community dataset using Bhattacharyya distance.\n\nArguments\n\ndata::DataFrame: DataFrame containing environmental variables where each row represents an observation.\npresence_absence::Vector{Int}: Vector indicating presence (1) or absence (0) for each observation in data.\nspecies::AbstractVector: Vector containing species identifiers corresponding to each observation in data, which must be a vector of strings.\nvar_names::Vector{String}=String[]: Optional vector specifying names for the environmental variables. If empty, default names will be used.\n\nReturns\n\nFloat64: The average Bhattacharyya distance across all unique species pairs.\n\nDetails\n\nFor each unique pair of species, the function:\nFilters observations where each species is present (presence_absence > 0)\nCalculates the niche dissimilarity using the MVNH_dissimilarity function\nExtracts the total Bhattacharyya distance value\nThe function then computes the mean of all pairwise Bhattacharyya distances\nSpecies pairs where either species has no presence data are skipped\nEach species pair is processed only once (i.e., sp1-sp2 is calculated, but sp2-sp1 is skipped)\nEnvironmental variables are assumed to follow a multivariate normal distribution\nVariables should be standardized before using this function to avoid bias from different scales\n\nExample\n\njulia> using MetaCommunityMetrics, Pipe, DataFrames, Statistics\n\njulia> df = @pipe load_sample_data() |>\n                      groupby(_, :Species) |>\n                      filter(row -> sum(row.Presence) > 1, _)|>\n                      DataFrame(_)\n53352×12 DataFrame\n   Row │ Year   Month  Day    Sampling_date_order  plot   Species  Abundance  Presence  Latitude  Longitude  standardized_temperature  standardized_precipitation \n       │ Int64  Int64  Int64  Int64                Int64  String3  Int64      Int64     Float64   Float64    Float64                 Float64                  \n───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │  2010      1     16                    1      1  BA               0         0      35.0     -110.0                0.829467              -1.4024\n     2 │  2010      1     16                    1      2  BA               0         0      35.0     -109.5               -1.12294               -0.0519895\n     3 │  2010      1     16                    1      4  BA               0         0      35.0     -108.5               -0.409808              -0.803663\n     4 │  2010      1     16                    1      8  BA               0         0      35.5     -109.5               -1.35913               -0.646369\n     5 │  2010      1     16                    1      9  BA               0         0      35.5     -109.0                0.0822                 1.09485\n   ⋮   │   ⋮      ⋮      ⋮             ⋮             ⋮       ⋮         ⋮         ⋮         ⋮          ⋮                ⋮                        ⋮\n 53348 │  2023      3     21                  117      9  SH               0         0      35.5     -109.0               -0.571565              -0.836345\n 53349 │  2023      3     21                  117     10  SH               0         0      35.5     -108.5               -2.33729               -0.398522\n 53350 │  2023      3     21                  117     12  SH               1         1      35.5     -107.5                0.547169               1.03257\n 53351 │  2023      3     21                  117     16  SH               0         0      36.0     -108.5               -0.815015               0.95971\n 53352 │  2023      3     21                  117     23  SH               0         0      36.5     -108.0                0.48949               -1.59416\n                                                                                                                                            53342 rows omitted\n\njulia> data = @pipe df |> \n           select(_, [:standardized_temperature, :standardized_precipitation])    \n53352×2 DataFrame\n   Row │ standardized_temperature  standardized_precipitation \n       │ Float64                 Float64                  \n───────┼──────────────────────────────────────────────────\n     1 │               0.829467              -1.4024\n     2 │              -1.12294               -0.0519895\n     3 │              -0.409808              -0.803663\n     4 │              -1.35913               -0.646369\n     5 │               0.0822                 1.09485\n   ⋮   │           ⋮                        ⋮\n 53348 │              -0.571565              -0.836345\n 53349 │              -2.33729               -0.398522\n 53350 │               0.547169               1.03257\n 53351 │              -0.815015               0.95971\n 53352 │               0.48949               -1.59416\n                                        53342 rows omitted\n\njulia> result = average_MVNH_dissimilarity(data, df.Presence, df.Species; var_names=[\"Temperature\", \"Precipitation\"])     \n0.03059942936454443\n\n\n\n\n\n","category":"function"},{"location":"Hypervolume/#References","page":"Hypervolume Functions","title":"References","text":"","category":"section"},{"location":"Hypervolume/","page":"Hypervolume Functions","title":"Hypervolume Functions","text":"Lu, Muyang, Kevin Winner, and Walter Jetz. A unifying framework for quantifying and comparing n‐dimensional hypervolumes. Methods in Ecology and Evolution 12.10, 1953-1968 (2021). https://doi.org/10.1111/2041-210X.13665","category":"page"}]
}
