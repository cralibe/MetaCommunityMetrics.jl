pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
filter(rowSums(.) !== 0)
df %>%
filter(Sampling_date_order == 50) %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
filter(rowSums(.) != 0)
df %>%
filter(Sampling_date_order == 50) %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
filter(colSums(.) !=0) %>%
filter(rowSums(.) != 0)
df %>%
filter(Sampling_date_order == 50) %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)
)
df %>%
filter(Sampling_date_order == 50) %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
test_data <- matrix(sample(c(0, 1, 2, 3), 80, replace = TRUE), nrow = 10, ncol = 8)
# Manually set some rows and columns to have a sum of zero
test_data[3, ] <- 0   # Set all abundances in row 3 to 0
test_data[ , 5] <- 0
test_data
test_data%>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
test_df <- as.data.frame(test_data)
test_df
test_df %>%
select(which(colSums(.) !=0))
test_df %>%
select(which(colSums(.) !=0)) %>%  filter(rowSums(.) != 0)
matrix_with_presence <- df %>%
filter(Sampling_date_order == 50) %>%
select(-Abundance) %>%
pivot_wider(names_from = Species, values_from = Presence, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
matrix_with_presence
?beta.div.comp
?microbenchmark
install.packages(bench)
install.packages("bench")
library(bench)
?mark
?beta.div.comp
mark(beta.div.comp(sample_matrix_abundance, coef = "J", quant =true),
iterations = 10000,
check = TRUE,
time_unit = "us")
mark(beta.div.comp(matrix_with_abundance, coef = "J", quant =true),
iterations = 10000,
check = TRUE,
time_unit = "us")
matrix_with_abundance <- df %>%
filter(Sampling_date_order == 50) %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
### The binary matrix
matrix_with_presence <- df %>%
filter(Sampling_date_order == 50) %>%
select(-Abundance) %>%
pivot_wider(names_from = Species, values_from = Presence, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
mark(beta.div.comp(matrix_with_abundance, coef = "J", quant =true),
iterations = 10000,
check = TRUE,
time_unit = "us")
mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
iterations = 10000,
check = TRUE,
time_unit = "us")
mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
iterations = 10,
check = TRUE,
time_unit = "us")
mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
iterations = 10000,
check = TRUE,
time_unit = "us")
result<-mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
iterations = 10000,
check = TRUE,
time_unit = "us")
beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE)
result
result$median
result$time
View(result$time)
View(result$time[[1]])
result$time[[1]]
mean(result$time)
mean(result$time[[1]])
result<-mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
beta.div.comp(matrix_with_abundance, coef = "J", quant = FALSE)
beta.div.comp(matrix_with_presence, coef = "J", quant = FALSE)
result<-mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
beta.div.comp(matrix_with_abundance, coef = "J", quant = FALSE),
beta.div.comp(matrix_with_presence, coef = "J", quant = FALSE),
iterations = 10000,
check = TRUE,
time_unit = "us")
dat <- data.frame(x = runif(100, 1, 1000), y=runif(10, 1, 1000))
dat
dat[dat$x > 500, ]
dat[which(dat$x > 500), ]
subset(dat, x > 500)
beta_diversity_1 <- mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = TRUE),
iterations = 10000,
check = TRUE,
time_unit = "us")
beta_diversity_1
mean(beta_diversity_1$time[[1]])
mean(beta_diversity_1$time[[1]])*1000
mean(beta_diversity_1$time[[1]])/1000
str(mean(beta_diversity_1$time[[1]]))
mean(beta_diversity_1$time[[1]])*1000
as.numeric(beta_diversity_1$time[[1]])
beta_diversity_1$time[[1]]
as.numeric(beta_diversity_1$time[[1]])
mean(as.numeric(beta_diversity_1$time[[1]]))*1e+6
beta_diversity_1
beta_diversity_1_mean_time_<-mean(as.numeric(beta_diversity_1$time[[1]]))*1e+6
beta_diversity_1_mean_time<-mean(as.numeric(beta_diversity_1$time[[1]]))*1e+6
beta_diversity_1_mean_time
beta_diversity_1
beta_diversity_1$memory
beta_diversity_1$mem_alloc
as.numeric(beta_diversity_1$mem_alloc)
beta_diversity_1_mean_time_us<-mean(as.numeric(beta_diversity_1$time[[1]]))*1e+6
beta_diversity_1_mem_kib<-as.numeric(beta_diversity_1$mem_alloc)/1024
beta_diversity_1_mem_kib
beta_diversity_1
as.numeric(beta_diversity_1$mem_alloc)
beta_diversity_1_mem_kib<-as.numeric(beta_diversity_1$mem_alloc)
beta_diversity_1$mem_alloc
as.numeric(beta_diversity_1$mem_alloc)
beta_diversity_1$time[[1]])
beta_diversity_1$time[[1]]
as.numeric(beta_diversity_1$time[[1]])
as.numeric(beta_diversity_1$mem_alloc)
beta_diversity_1$mem_alloc
as.numeric(beta_diversity_1$mem_alloc)/1024
beta_diversity_1_mean_time_us
beta_diversity_1$time[[1]]
mean(beta_diversity_1$time[[1]])
as.numeric(mean(beta_diversity_1$time[[1]]))
beta_diversity_1_mean_time_us<-as.numeric(mean(beta_diversity_1$time[[1]]))*1e+6
beta_diversity_1_mean_time_us
print(as.numeric(mean(beta_diversity_1$time[[1]]))*1e+6, as.numeric(beta_diversity_1$mem_alloc)/1024)
print(as.numeric(mean(beta_diversity_1$time[[1]]))*1e+6, (as.numeric(beta_diversity_1$mem_alloc)/1024))
print((as.numeric(mean(beta_diversity_1$time[[1]]))*1e+6), (as.numeric(beta_diversity_1$mem_alloc)/1024))
execution_time_microseconds <- as.numeric(mean(beta_diversity_1$time[[1]])) * 1e+6
memory_usage_kib <- as.numeric(beta_diversity_1$mem_alloc) / 1024
# Print the results
cat("Execution Time (Microseconds):", execution_time_microseconds, "\n")
cat("Memory Usage (KiB):", memory_usage_kib, "\n")
beta_diversity_2 <- mark(beta.div.comp(matrix_with_abundance, coef = "J", quant = FALSE),
iterations = 10000,
check = TRUE,
time_unit = "us")
beta_diversity_2
execution_time_microseconds <- as.numeric(mean(beta_diversity_2$time[[1]])) * 1e+6
memory_usage_kib <- as.numeric(beta_diversity_2$mem_alloc) / 1024
# Print the results
cat("Execution Time (Microseconds):", execution_time_microseconds, "\n")
cat("Memory Usage (KiB):", memory_usage_kib, "\n")
beta_diversity_3 <- mark(beta.div.comp(matrix_with_presence, coef = "J", quant = FALSE),
iterations = 10000,
check = TRUE,
time_unit = "us")
execution_time_microseconds <- as.numeric(mean(beta_diversity_3$time[[1]])) * 1e+6
memory_usage_kib <- as.numeric(beta_diversity_3$mem_alloc) / 1024
cat("Execution Time (Microseconds):", execution_time_microseconds, "\n")
cat("Memory Usage (KiB):", memory_usage_kib, "\n")
beta_diversity_3
beta_diversity_2
beta_diversity_1
df
beta.div.comp(matrix_with_presence, coef = "J", quant = FALSE)
mean_spatial_beta_div_comp <-()
mean_spatial_beta_div_comp <-[]
mean_spatial_beta_div_comp <-list()
mean_spatial_beta_div_comp
spatial_beta_div_comp <-list()
df$Sampling_date_order
time=1
df %>%
filter(Sampling_date_order == time)
mean(beta_diversity_3$time[[1]])
mean(beta_diversity_2$time[[1]])
mean(beta_diversity_1$time[[1]])
beta_diversity_2$mem_alloc
execution_time_microseconds <- mean(beta_diversity_2$time[[1]])
memory_usage_kib <- as.numeric(beta_diversity_2$mem_alloc) / 1024
# Print the results
cat("Execution Time (Microseconds):", execution_time_microseconds, "\n")
cat("Memory Usage (KiB):", memory_usage_kib, "\n")
execution_time_microseconds <- mean(beta_diversity_2$time[[1]])
execution_time_microseconds
execution_time_microseconds <- mean(beta_diversity_2$time[[1]])) * 1e+6
execution_time_microseconds <- mean(beta_diversity_2$time[[1]])) * 1e+6
execution_time_microseconds <- mean(beta_diversity_2$time[[1]])* 1e+6
memory_usage_kib <- as.numeric(beta_diversity_2$mem_alloc) / 1024
# Print the results
cat("Execution Time (Microseconds):", execution_time_microseconds, "\n")
cat("Memory Usage (KiB):", memory_usage_kib, "\n")
install.packages("spaa")
library(spaa)
?niche.overlap
data(datasample)
datasample
df
library(tidyverse)
community_matrix<-df%>%
pivot_wider(names_from = Species, values_from = Abundance)
community_matrix
df %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
df %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
pivot_wider(names_from = Species, values_from = Abundance)
df %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
community_matrix<-df %>%
select(-Presence) %>%
pivot_wider(names_from = Species, values_from = Abundance, values_fill=0) %>%
select(-c(Year, Month, Day, Sampling_date_order, plot, Longitude, Latitude)) %>%
select(which(colSums(.) !=0)) %>%
filter(rowSums(.) != 0)
community_matrix
niche.overlap(community_matrix, method = c("pianka"))
niche_overlap_result <- niche.overlap(community_matrix, method = c("pianka"))
niche_overlap_result
as.data.frame(niche_overlap_result)
result_df<-as.data.frame(niche_overlap_result)
summary_df <- data.frame(mean_niche_overlap_index=mean(result_df$x),
min_niche_overlap_index=min(result_df$x),
max_niche_overlap_index=max(result_df$x))
summary_df
community_matrix
df
library(DNCImper)
??DNCI_multigroup
#Data Wrangling
community_matrix
matrix_with_abundance
comm_df_for_DNCI<-read.csv("~/.julia/dev/MetaCommunityMetrics/benchmarks/benchmark_r/data/DNCI_comm.csv")
comm_df_for_DNCI
grouping_for_DNCI
grouping_for_DNCI<-read.csv("~/.julia/dev/MetaCommunityMetrics/benchmarks/benchmark_r/data/cluster_list_t1.csv")
grouping_for_DNCI
as.matrix(comm_df_for_DNCI)
as.vector(grouping_for_DNCI$Group)
grouping_for_DNCI$Group
result <- DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
id = "no_name",
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
library(DNCImper)
result <- DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
id = "no_name",
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
result <- DNCImper:::DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
id = "no_name",
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
#### Benchmark the DNCI function
result
DNCImper:::DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
id = "no_name",
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
as.matrix(comm_df_for_DNCI)
grouping_for_DNCI$Group
DNCImper:::DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
grouping=grouping_for_DNCI$Group
x=as.matrix(comm_df_for_DNCI)
group.combinations <- combn(unique(sort(grouping)),2)
group.combinations
ddelta <- NULL
or(i in 1:NCOL(group.combinations)) {
for(i in 1:NCOL(group.combinations)) {
splitx <- split(x,grouping)
#Ici symmetrize:
if(symmetrize == TRUE)
{
Add <- which(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]])) == max(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]]))))
if(Add == 1)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[1,i]]][,1]),
length(splitx[[group.combinations[2,i]]][,1]))
splitx[[group.combinations[1,i]]] <- splitx[[group.combinations[1,i]]][sampled_lines,]
}
if(Add == 2)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[2,i]]][,1]),
length(splitx[[group.combinations[1,i]]][,1]))
splitx[[group.combinations[2,i]]] <- splitx[[group.combinations[2,i]]][sampled_lines,]
}
}
paired.x <- rbind(splitx[[group.combinations[1,i]]],
splitx[[group.combinations[2,i]]])
# remove empty species
ifzero <- which(apply(paired.x, 2, sum) == 0)
if(length(ifzero > 0)){
paired.x <- paired.x[,-which(colSums(paired.x)==0)]}
if(length(which(rowSums(paired.x) == 0)) != 0){stop("ERROR : A row/sample is empty")}
group.pair <- c(rep(group.combinations[1,i], NROW(splitx[[group.combinations[1,i]]])),
rep(group.combinations[2,i], NROW(splitx[[group.combinations[2,i]]])))
ddelta <- rbind(ddelta, DNCImper:::DNCI.ses(x=paired.x,grouping=group.pair,id=id, Nperm = Nperm, count = count, plotSIMPER = plotSIMPER, dataTYPE = dataTYPE)) #here is the part that calculates the index based on PERSIMPER
}
symmetrize = FALSE
plotSIMPER = FALSE
count = FALSE
id = "no_name"
for(i in 1:NCOL(group.combinations)) {
splitx <- split(x,grouping)
#Ici symmetrize:
if(symmetrize == TRUE)
{
Add <- which(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]])) == max(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]]))))
if(Add == 1)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[1,i]]][,1]),
length(splitx[[group.combinations[2,i]]][,1]))
splitx[[group.combinations[1,i]]] <- splitx[[group.combinations[1,i]]][sampled_lines,]
}
if(Add == 2)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[2,i]]][,1]),
length(splitx[[group.combinations[1,i]]][,1]))
splitx[[group.combinations[2,i]]] <- splitx[[group.combinations[2,i]]][sampled_lines,]
}
}
paired.x <- rbind(splitx[[group.combinations[1,i]]],
splitx[[group.combinations[2,i]]])
# remove empty species
ifzero <- which(apply(paired.x, 2, sum) == 0)
if(length(ifzero > 0)){
paired.x <- paired.x[,-which(colSums(paired.x)==0)]}
if(length(which(rowSums(paired.x) == 0)) != 0){stop("ERROR : A row/sample is empty")}
group.pair <- c(rep(group.combinations[1,i], NROW(splitx[[group.combinations[1,i]]])),
rep(group.combinations[2,i], NROW(splitx[[group.combinations[2,i]]])))
ddelta <- rbind(ddelta, DNCImper:::DNCI.ses(x=paired.x,grouping=group.pair,id=id, Nperm = Nperm, count = count, plotSIMPER = plotSIMPER, dataTYPE = dataTYPE)) #here is the part that calculates the index based on PERSIMPER
}
dataTYPE = "prab"
for(i in 1:NCOL(group.combinations)) {
splitx <- split(x,grouping)
#Ici symmetrize:
if(symmetrize == TRUE)
{
Add <- which(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]])) == max(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]]))))
if(Add == 1)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[1,i]]][,1]),
length(splitx[[group.combinations[2,i]]][,1]))
splitx[[group.combinations[1,i]]] <- splitx[[group.combinations[1,i]]][sampled_lines,]
}
if(Add == 2)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[2,i]]][,1]),
length(splitx[[group.combinations[1,i]]][,1]))
splitx[[group.combinations[2,i]]] <- splitx[[group.combinations[2,i]]][sampled_lines,]
}
}
paired.x <- rbind(splitx[[group.combinations[1,i]]],
splitx[[group.combinations[2,i]]])
# remove empty species
ifzero <- which(apply(paired.x, 2, sum) == 0)
if(length(ifzero > 0)){
paired.x <- paired.x[,-which(colSums(paired.x)==0)]}
if(length(which(rowSums(paired.x) == 0)) != 0){stop("ERROR : A row/sample is empty")}
group.pair <- c(rep(group.combinations[1,i], NROW(splitx[[group.combinations[1,i]]])),
rep(group.combinations[2,i], NROW(splitx[[group.combinations[2,i]]])))
ddelta <- rbind(ddelta, DNCImper:::DNCI.ses(x=paired.x,grouping=group.pair,id=id, Nperm = Nperm, count = count, plotSIMPER = plotSIMPER, dataTYPE = dataTYPE)) #here is the part that calculates the index based on PERSIMPER
}
Nperm = 1000
for(i in 1:NCOL(group.combinations)) {
splitx <- split(x,grouping)
#Ici symmetrize:
if(symmetrize == TRUE)
{
Add <- which(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]])) == max(c(NROW(splitx[[group.combinations[1,i]]]),
NROW(splitx[[group.combinations[2,i]]]))))
if(Add == 1)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[1,i]]][,1]),
length(splitx[[group.combinations[2,i]]][,1]))
splitx[[group.combinations[1,i]]] <- splitx[[group.combinations[1,i]]][sampled_lines,]
}
if(Add == 2)
{
sampled_lines <- sample(1:length(splitx[[group.combinations[2,i]]][,1]),
length(splitx[[group.combinations[1,i]]][,1]))
splitx[[group.combinations[2,i]]] <- splitx[[group.combinations[2,i]]][sampled_lines,]
}
}
paired.x <- rbind(splitx[[group.combinations[1,i]]],
splitx[[group.combinations[2,i]]])
# remove empty species
ifzero <- which(apply(paired.x, 2, sum) == 0)
if(length(ifzero > 0)){
paired.x <- paired.x[,-which(colSums(paired.x)==0)]}
if(length(which(rowSums(paired.x) == 0)) != 0){stop("ERROR : A row/sample is empty")}
group.pair <- c(rep(group.combinations[1,i], NROW(splitx[[group.combinations[1,i]]])),
rep(group.combinations[2,i], NROW(splitx[[group.combinations[2,i]]])))
ddelta <- rbind(ddelta, DNCImper:::DNCI.ses(x=paired.x,grouping=group.pair,id=id, Nperm = Nperm, count = count, plotSIMPER = plotSIMPER, dataTYPE = dataTYPE)) #here is the part that calculates the index based on PERSIMPER
}
i=1
1:NCOL(group.combinations)
splitx <- split(x,grouping)
paired.x <- rbind(splitx[[group.combinations[1,i]]],
splitx[[group.combinations[2,i]]])
group.combinations[2,i]
splitx[[group.combinations[2,i]]]
splitx[[group.combinations[1,i]]]
rbind(splitx[[group.combinations[1,i]]],
+                   splitx[[group.combinations[2,i]]])
ifzero <- which(apply(paired.x, 2, sum) == 0)
print(dim(splitx[[group.combinations[1,i]]]))
splitx[[group.combinations[1,i]]]
splitx[[group.combinations[2,i]]]
rbind(splitx[[group.combinations[1,i]]],
+                   splitx[[group.combinations[2,i]]])
i=2
rbind(splitx[[group.combinations[1,i]]],
+                   splitx[[group.combinations[2,i]]])
splitx[[group.combinations[2,i]]]
NCOL(group.combinations)
group.combinations
i=1
dim(splitx[[group.combinations[1,i]]])
R.version.string
library(devtools)
devtools::install_github("Corentin-Gibert-Paleontology/DNCImper")
library(devtools)
devtools::install_github("Corentin-Gibert-Paleontology/DNCImper", force =TRUE)
library(DNCImper)
DNCImper:::DNCI_multigroup(
as.matrix(comm_df_for_DNCI),
grouping_for_DNCI$Group,
Nperm = 1000,
count = FALSE,
symmetrize = FALSE,
plotSIMPER = FALSE
)
